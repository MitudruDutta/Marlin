# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[]", "name": "oracle_address"}, {"type": "byte[]", "name": "tokenization_address"}, {"type": "byte[]", "name": "amm_address"}], "name": "initialize", "returns": {"type": "string"}, "desc": "Initialize the auto converter", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "enabled"}, {"type": "uint64", "name": "threshold_price"}, {"type": "uint64", "name": "maturity"}], "name": "configure_conversion", "returns": {"type": "string"}, "desc": "Configure automatic conversion for user", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "amount"}], "name": "deposit_yt_tokens", "returns": {"type": "string"}, "desc": "Deposit YT tokens for conversion (for testing)", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[]", "name": "user"}, {"type": "uint64", "name": "min_pt_amount"}, {"type": "uint64", "name": "deadline"}], "name": "execute_conversion", "returns": {"type": "string"}, "desc": "Execute YT to PT conversion", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[]", "name": "user"}], "name": "can_execute_conversion", "returns": {"type": "uint64"}, "desc": "Check if conversion can be executed for user", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "get_user_config", "returns": {"type": "(uint64,uint64,uint64,uint64)"}, "desc": "Get user's conversion configuration", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "get_user_balances", "returns": {"type": "(uint64,uint64)"}, "desc": "Get user's YT and PT balances", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "get_conversion_info", "returns": {"type": "(uint64,uint64,uint64)"}, "desc": "Get conversion information", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "yt_amount"}], "name": "calculate_conversion_output", "returns": {"type": "(uint64,uint64)"}, "desc": "Calculate expected PT output for YT input", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "maturity"}], "name": "add_maturity", "returns": {"type": "string"}, "desc": "Add a maturity for conversion", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "remove_maturity", "returns": {"type": "string"}, "desc": "Remove user's maturity", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "new_fee"}], "name": "set_conversion_fee", "returns": {"type": "string"}, "desc": "Set conversion fee (admin only)", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "pause_converter", "returns": {"type": "string"}, "desc": "Pause the converter (admin only)", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "unpause_converter", "returns": {"type": "string"}, "desc": "Unpause the converter (admin only)", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "emergency_disable_conversion", "returns": {"type": "string"}, "desc": "Emergency disable conversion for user", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "amount"}], "name": "withdraw_pt_tokens", "returns": {"type": "string"}, "desc": "Withdraw PT tokens", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "yt_amount"}, {"type": "uint64", "name": "current_price"}], "name": "get_ai_recommendation", "returns": {"type": "(uint64,string)"}, "desc": "Get AI recommendation for conversion (simplified)", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[]", "name": "oracle_address"}, {"type": "byte[]", "name": "tokenization_address"}, {"type": "byte[]", "name": "amm_address"}], "name": "update_addresses", "returns": {"type": "string"}, "desc": "Update contract addresses (admin only)", "events": [], "readonly": false, "recommendations": {}}], "name": "YTAutoConverter", "state": {"keys": {"box": {}, "global": {"admin": {"key": "YWRtaW4=", "keyType": "AVMString", "valueType": "AVMBytes"}, "oracle_address": {"key": "b3JhY2xlX2FkZHJlc3M=", "keyType": "AVMString", "valueType": "AVMBytes"}, "tokenization_address": {"key": "dG9rZW5pemF0aW9uX2FkZHJlc3M=", "keyType": "AVMString", "valueType": "AVMBytes"}, "amm_address": {"key": "YW1tX2FkZHJlc3M=", "keyType": "AVMString", "valueType": "AVMBytes"}, "conversion_fee": {"key": "Y29udmVyc2lvbl9mZWU=", "keyType": "AVMString", "valueType": "AVMUint64"}, "is_paused": {"key": "aXNfcGF1c2Vk", "keyType": "AVMString", "valueType": "AVMUint64"}, "total_conversions": {"key": "dG90YWxfY29udmVyc2lvbnM=", "keyType": "AVMString", "valueType": "AVMUint64"}, "max_slippage": {"key": "bWF4X3NsaXBwYWdl", "keyType": "AVMString", "valueType": "AVMUint64"}, "fee_denominator": {"key": "ZmVlX2Rlbm9taW5hdG9y", "keyType": "AVMString", "valueType": "AVMUint64"}}, "local": {"conversion_enabled": {"key": "Y29udmVyc2lvbl9lbmFibGVk", "keyType": "AVMString", "valueType": "AVMUint64"}, "threshold_price": {"key": "dGhyZXNob2xkX3ByaWNl", "keyType": "AVMString", "valueType": "AVMUint64"}, "user_maturity": {"key": "dXNlcl9tYXR1cml0eQ==", "keyType": "AVMString", "valueType": "AVMUint64"}, "conversion_executed": {"key": "Y29udmVyc2lvbl9leGVjdXRlZA==", "keyType": "AVMString", "valueType": "AVMUint64"}, "yt_balance": {"key": "eXRfYmFsYW5jZQ==", "keyType": "AVMString", "valueType": "AVMUint64"}, "pt_balance": {"key": "cHRfYmFsYW5jZQ==", "keyType": "AVMString", "valueType": "AVMUint64"}}}, "maps": {"box": {}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 4, "ints": 5}, "local": {"bytes": 0, "ints": 6}}}, "structs": {}, "byteCode": {"approval": "CiADAAGQTiYRBBUffHUOY29udmVyc2lvbl9mZWUKeXRfYmFsYW5jZQVhZG1pbglpc19wYXVzZWQSY29udmVyc2lvbl9lbmFibGVkD3RocmVzaG9sZF9wcmljZRNjb252ZXJzaW9uX2V4ZWN1dGVkCnB0X2JhbGFuY2URdG90YWxfY29udmVyc2lvbnMNdXNlcl9tYXR1cml0eQ9mZWVfZGVub21pbmF0b3IOb3JhY2xlX2FkZHJlc3MUdG9rZW5pemF0aW9uX2FkZHJlc3MLYW1tX2FkZHJlc3MQQ29udmVydGVyIHBhdXNlZBJDb252ZXJ0ZXIgdW5wYXVzZWQxGEAAFoAMbWF4X3NsaXBwYWdlgfQDZycLJGcxG0ECaIISBGpp310Ea5qvNAQ56IxZBGrXwwIEplfi+QRmdtlRBP5O39kEa9FCjARU++w1BFmRowEExzDSLAQa8DcABEUmVLQE0yggQwQRY47CBMAgXa0Eaf8BUARxYTUPNhoAjhIBuQGVAXkBUwE8ASwBHAEMAPgA3ADEAKgAkAB4AGAARAAsAAIiQzEZFEQxGEQ2GgFXAgA2GgJXAgA2GgNXAgCIB3RJFRZXBgJMUChMULAjQzEZFEQxGEQ2GgEXNhoCF4gGWChMULAjQzEZFEQxGEQ2GgEXiAXfSRUWVwYCTFAoTFCwI0MxGRREMRhEiAV9SRUWVwYCTFAoTFCwI0MxGRREMRhEiAVTSRUWVwYCTFAoTFCwI0MxGRREMRhEiAUpSRUWVwYCTFAoTFCwI0MxGRREMRhENhoBF4gEnEkVFlcGAkxQKExQsCNDMRkURDEYRIgES0kVFlcGAkxQKExQsCNDMRkURDEYRDYaAReIA+FJFRZXBgJMUChMULAjQzEZFEQxGEQ2GgEXiAOMKExQsCNDMRkURDEYRIgDZShMULAjQzEZFEQxGESIA0QoTFCwI0MxGRREMRhEiAMJKExQsCNDMRkURDEYRDYaAVcCAIgCvRYoTFCwI0MxGRREMRhENhoBVwIANhoCFzYaAxeIAdlJFRZXBgJMUChMULAjQzEZFEQxGEQ2GgEXiAFfSRUWVwYCTFAoTFCwI0MxGRREMRhENhoBFzYaAhc2GgMXiACzSRUWVwYCTFAoTFCwI0MxGRREMRhENhoBVwIANhoCVwIANhoDVwIAiAAZSRUWVwYCTFAoTFCwI0MxGUD+GDEYFEQjQ4oDATEAMgkSRCsxAGcnDIv9ZycNi/5nJw6L/2cpgR5nJwQiZycJImeAG1lUQXV0b0NvbnZlcnRlciBpbml0aWFsaXplZLCAJ0F1dG8gY29udmVydGVyIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseYmKAwGL/kSL/zIHDUQxACcFi/1mMQAnBov+ZjEAJwqL/2YxACcHImaL/RaAIUNvbnZlcnNpb24gY29uZmlndXJlZCAtIEVuYWJsZWQ6IExQgAwgVGhyZXNob2xkOiBQi/4WULCAIkNvbnZlcnNpb24gY29uZmlndXJlZCBzdWNjZXNzZnVsbHmJigEBi/9EMQAiKmNEi/8IMQAqTwJmi/8WgB5ZVCB0b2tlbnMgZGVwb3NpdGVkIC0gQW1vdW50OiBMULCAIFlUIHRva2VucyBkZXBvc2l0ZWQgc3VjY2Vzc2Z1bGx5iYoDASInBGVEFEQyB4v/DkQxACInBWNEIxJEMQAiJwdjRBREMQAiJwZjREQxACIqY0RJRCIpZURLAQsiJwtlRApLAUwJgd5NCyQKSYv+D0QxACoiZjEAIicIY0RLAQgxACcITwJmMQAnByNmIicJZUQjCCcJTGdMFoAaQ29udmVyc2lvbiBleGVjdXRlZCAtIFlUOiBMUIAFIFBUOiBQTBZQsIAgQ29udmVyc2lvbiBleGVjdXRlZCBzdWNjZXNzZnVsbHmJigEBMQAiJwVjREAAAiKJMQAiJwdjRCMSQQACIokxACIqY0RAAAIiiTEAIicGY0RAAAIiiSOJMQAiJwVjRBYxACInBmNEFjEAIicKY0QWMQAiJwdjRBZPA08DUE8CUExQiTEAIipjRBYxACInCGNEFlCJIillRBYiJwllRBYiJwRlRBZOAlBMUImKAQGL/0AAE4AQAAAAAAAAAAAAAAAAAAAAAIkiKWVEi/8LIicLZUQKi/9LAQlJgTILJAoJFkwWUImKAQGL/zIHDUQxACcKi/9mi/8WgBhNYXR1cml0eSBhZGRlZCAtIFZhbHVlOiBMULCAG01hdHVyaXR5IGFkZGVkIHN1Y2Nlc3NmdWxseYkxACcKImaAEE1hdHVyaXR5IHJlbW92ZWSwgB1NYXR1cml0eSByZW1vdmVkIHN1Y2Nlc3NmdWxseYmKAQExACIrZUQSRIv/gegHDkQiKWVEKYv/ZxaAHkNvbnZlcnNpb24gZmVlIHVwZGF0ZWQgLSBPbGQ6IExQgAYgTmV3OiBQi/8WULCAI0NvbnZlcnNpb24gZmVlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5iTEAIitlRBJEJwQjZycPsCcPiTEAIitlRBJEJwQiZycQsCcQiTEAJwUiZoAdQ29udmVyc2lvbiBlbWVyZ2VuY3kgZGlzYWJsZWSwgCFDb252ZXJzaW9uIGRpc2FibGVkIGZvciBlbWVyZ2VuY3mJigEBi/9EMQAiJwhjREmL/w9Ei/8JMQAnCE8CZov/FoAeUFQgdG9rZW5zIHdpdGhkcmF3biAtIEFtb3VudDogTFCwgCBQVCB0b2tlbnMgd2l0aGRyYXduIHN1Y2Nlc3NmdWxseYmKAgGAAIv+QAAngCMAAAAAAAAAAAAKABdObyBZVCB0b2tlbnMgdG8gY29udmVydEyJMQAiJwZjTElOAowARIv/DkEAOIA0AAAAAAAAAAEACgAoUmVjb21tZW5kIGNvbnZlcnNpb24gLSB0aHJlc2hvbGQgcmVhY2hlZEyJiwCL/wmBZAuL/wqBBQxBADmANQAAAAAAAAABAAoAKVJlY29tbWVuZCBjb252ZXJzaW9uIC0gY2xvc2UgdG8gdGhyZXNob2xkTImAMgAAAAAAAAAAAAoAJkhvbGQgWVQgdG9rZW5zIC0gdGhyZXNob2xkIG5vdCByZWFjaGVkTImKAwExACIrZUQSRCcMi/1nJw2L/mcnDov/Z4AaQ29udHJhY3QgYWRkcmVzc2VzIHVwZGF0ZWSwgCdDb250cmFjdCBhZGRyZXNzZXMgdXBkYXRlZCBzdWNjZXNzZnVsbHmJ", "clear": "CoEBQw=="}, "desc": "AI-powered YT to PT auto converter", "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLl9fYWxnb3B5X2VudHJ5cG9pbnRfd2l0aF9pbml0KCkgLT4gdWludDY0OgptYWluOgogICAgaW50Y2Jsb2NrIDAgMSAxMDAwMAogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1ICJjb252ZXJzaW9uX2ZlZSIgInl0X2JhbGFuY2UiICJhZG1pbiIgImlzX3BhdXNlZCIgImNvbnZlcnNpb25fZW5hYmxlZCIgInRocmVzaG9sZF9wcmljZSIgImNvbnZlcnNpb25fZXhlY3V0ZWQiICJwdF9iYWxhbmNlIiAidG90YWxfY29udmVyc2lvbnMiICJ1c2VyX21hdHVyaXR5IiAiZmVlX2Rlbm9taW5hdG9yIiAib3JhY2xlX2FkZHJlc3MiICJ0b2tlbml6YXRpb25fYWRkcmVzcyIgImFtbV9hZGRyZXNzIiAweDQzNmY2ZTc2NjU3Mjc0NjU3MjIwNzA2MTc1NzM2NTY0IDB4NDM2ZjZlNzY2NTcyNzQ2NTcyMjA3NTZlNzA2MTc1NzM2NTY0CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NDQtNDUKICAgIC8vICMgQ29uc3RhbnRzCiAgICAvLyBzZWxmLm1heF9zbGlwcGFnZSA9IFVJbnQ2NCg1MDApICAjIDUlCiAgICBwdXNoYnl0ZXMgIm1heF9zbGlwcGFnZSIKICAgIHB1c2hpbnQgNTAwIC8vIDUwMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo0NgogICAgLy8gc2VsZi5mZWVfZGVub21pbmF0b3IgPSBVSW50NjQoMTAwMDApCiAgICBieXRlYyAxMSAvLyAiZmVlX2Rlbm9taW5hdG9yIgogICAgaW50Y18yIC8vIDEwMDAwCiAgICBhcHBfZ2xvYmFsX3B1dAoKbWFpbl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYmFyZV9yb3V0aW5nQDIzCiAgICBwdXNoYnl0ZXNzIDB4NmE2OWRmNWQgMHg2YjlhYWYzNCAweDM5ZTg4YzU5IDB4NmFkN2MzMDIgMHhhNjU3ZTJmOSAweDY2NzZkOTUxIDB4ZmU0ZWRmZDkgMHg2YmQxNDI4YyAweDU0ZmJlYzM1IDB4NTk5MWEzMDEgMHhjNzMwZDIyYyAweDFhZjAzNzAwIDB4NDUyNjU0YjQgMHhkMzI4MjA0MyAweDExNjM4ZWMyIDB4YzAyMDVkYWQgMHg2OWZmMDE1MCAweDcxNjEzNTBmIC8vIG1ldGhvZCAiaW5pdGlhbGl6ZShieXRlW10sYnl0ZVtdLGJ5dGVbXSlzdHJpbmciLCBtZXRob2QgImNvbmZpZ3VyZV9jb252ZXJzaW9uKHVpbnQ2NCx1aW50NjQsdWludDY0KXN0cmluZyIsIG1ldGhvZCAiZGVwb3NpdF95dF90b2tlbnModWludDY0KXN0cmluZyIsIG1ldGhvZCAiZXhlY3V0ZV9jb252ZXJzaW9uKGJ5dGVbXSx1aW50NjQsdWludDY0KXN0cmluZyIsIG1ldGhvZCAiY2FuX2V4ZWN1dGVfY29udmVyc2lvbihieXRlW10pdWludDY0IiwgbWV0aG9kICJnZXRfdXNlcl9jb25maWcoKSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJnZXRfdXNlcl9iYWxhbmNlcygpKHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJnZXRfY29udmVyc2lvbl9pbmZvKCkodWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJjYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXQodWludDY0KSh1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiYWRkX21hdHVyaXR5KHVpbnQ2NClzdHJpbmciLCBtZXRob2QgInJlbW92ZV9tYXR1cml0eSgpc3RyaW5nIiwgbWV0aG9kICJzZXRfY29udmVyc2lvbl9mZWUodWludDY0KXN0cmluZyIsIG1ldGhvZCAicGF1c2VfY29udmVydGVyKClzdHJpbmciLCBtZXRob2QgInVucGF1c2VfY29udmVydGVyKClzdHJpbmciLCBtZXRob2QgImVtZXJnZW5jeV9kaXNhYmxlX2NvbnZlcnNpb24oKXN0cmluZyIsIG1ldGhvZCAid2l0aGRyYXdfcHRfdG9rZW5zKHVpbnQ2NClzdHJpbmciLCBtZXRob2QgImdldF9haV9yZWNvbW1lbmRhdGlvbih1aW50NjQsdWludDY0KSh1aW50NjQsc3RyaW5nKSIsIG1ldGhvZCAidXBkYXRlX2FkZHJlc3NlcyhieXRlW10sYnl0ZVtdLGJ5dGVbXSlzdHJpbmciCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2luaXRpYWxpemVfcm91dGVANSBtYWluX2NvbmZpZ3VyZV9jb252ZXJzaW9uX3JvdXRlQDYgbWFpbl9kZXBvc2l0X3l0X3Rva2Vuc19yb3V0ZUA3IG1haW5fZXhlY3V0ZV9jb252ZXJzaW9uX3JvdXRlQDggbWFpbl9jYW5fZXhlY3V0ZV9jb252ZXJzaW9uX3JvdXRlQDkgbWFpbl9nZXRfdXNlcl9jb25maWdfcm91dGVAMTAgbWFpbl9nZXRfdXNlcl9iYWxhbmNlc19yb3V0ZUAxMSBtYWluX2dldF9jb252ZXJzaW9uX2luZm9fcm91dGVAMTIgbWFpbl9jYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXRfcm91dGVAMTMgbWFpbl9hZGRfbWF0dXJpdHlfcm91dGVAMTQgbWFpbl9yZW1vdmVfbWF0dXJpdHlfcm91dGVAMTUgbWFpbl9zZXRfY29udmVyc2lvbl9mZWVfcm91dGVAMTYgbWFpbl9wYXVzZV9jb252ZXJ0ZXJfcm91dGVAMTcgbWFpbl91bnBhdXNlX2NvbnZlcnRlcl9yb3V0ZUAxOCBtYWluX2VtZXJnZW5jeV9kaXNhYmxlX2NvbnZlcnNpb25fcm91dGVAMTkgbWFpbl93aXRoZHJhd19wdF90b2tlbnNfcm91dGVAMjAgbWFpbl9nZXRfYWlfcmVjb21tZW5kYXRpb25fcm91dGVAMjEgbWFpbl91cGRhdGVfYWRkcmVzc2VzX3JvdXRlQDIyCgptYWluX2FmdGVyX2lmX2Vsc2VAMjU6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgaW50Y18wIC8vIDAKICAgIHJldHVybgoKbWFpbl91cGRhdGVfYWRkcmVzc2VzX3JvdXRlQDIyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMxMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgdXBkYXRlX2FkZHJlc3NlcwogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0X2FpX3JlY29tbWVuZGF0aW9uX3JvdXRlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI5NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjk1CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGNhbGxzdWIgZ2V0X2FpX3JlY29tbWVuZGF0aW9uCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3dpdGhkcmF3X3B0X3Rva2Vuc19yb3V0ZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI2OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIHdpdGhkcmF3X3B0X3Rva2VucwogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZW1lcmdlbmN5X2Rpc2FibGVfY29udmVyc2lvbl9yb3V0ZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNjAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGVtZXJnZW5jeV9kaXNhYmxlX2NvbnZlcnNpb24KICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3VucGF1c2VfY29udmVydGVyX3JvdXRlQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI1MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgdW5wYXVzZV9jb252ZXJ0ZXIKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3BhdXNlX2NvbnZlcnRlcl9yb3V0ZUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNDIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIHBhdXNlX2NvbnZlcnRlcgogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc2V0X2NvbnZlcnNpb25fZmVlX3JvdXRlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIzMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjMwCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgc2V0X2NvbnZlcnNpb25fZmVlCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9yZW1vdmVfbWF0dXJpdHlfcm91dGVAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjIyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiByZW1vdmVfbWF0dXJpdHkKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2FkZF9tYXR1cml0eV9yb3V0ZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMTEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGFkZF9tYXR1cml0eQogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY2FsY3VsYXRlX2NvbnZlcnNpb25fb3V0cHV0X3JvdXRlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE5NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTk2CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGNhbGxzdWIgY2FsY3VsYXRlX2NvbnZlcnNpb25fb3V0cHV0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF9jb252ZXJzaW9uX2luZm9fcm91dGVAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTg3CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBnZXRfY29udmVyc2lvbl9pbmZvCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF91c2VyX2JhbGFuY2VzX3JvdXRlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE3OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgZ2V0X3VzZXJfYmFsYW5jZXMKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0X3VzZXJfY29uZmlnX3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE2OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgZ2V0X3VzZXJfY29uZmlnCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2Nhbl9leGVjdXRlX2NvbnZlcnNpb25fcm91dGVAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNTAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNTAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBjYW5fZXhlY3V0ZV9jb252ZXJzaW9uCiAgICBpdG9iCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2V4ZWN1dGVfY29udmVyc2lvbl9yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjEwNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjEwNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGV4ZWN1dGVfY29udmVyc2lvbgogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVwb3NpdF95dF90b2tlbnNfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo5NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6OTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgY2FsbHN1YiBkZXBvc2l0X3l0X3Rva2VucwogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY29uZmlndXJlX2NvbnZlcnNpb25fcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo3NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NzcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgY2FsbHN1YiBjb25maWd1cmVfY29udmVyc2lvbgogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faW5pdGlhbGl6ZV9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjU2CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMxCiAgICAvLyBjbGFzcyBZVEF1dG9Db252ZXJ0ZXIoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo1NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGluaXRpYWxpemUKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2JhcmVfcm91dGluZ0AyMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDI1CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIuaW5pdGlhbGl6ZShvcmFjbGVfYWRkcmVzczogYnl0ZXMsIHRva2VuaXphdGlvbl9hZGRyZXNzOiBieXRlcywgYW1tX2FkZHJlc3M6IGJ5dGVzKSAtPiBieXRlczoKaW5pdGlhbGl6ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo1Ni02MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICAvLyBkZWYgaW5pdGlhbGl6ZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIG9yYWNsZV9hZGRyZXNzOiBCeXRlcywKICAgIC8vICAgICB0b2tlbml6YXRpb25fYWRkcmVzczogQnl0ZXMsCiAgICAvLyAgICAgYW1tX2FkZHJlc3M6IEJ5dGVzLAogICAgLy8gKSAtPiBTdHJpbmc6CiAgICBwcm90byAzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo2NAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgIk9ubHkgY3JlYXRvciBjYW4gaW5pdGlhbGl6ZSIKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IGNyZWF0b3IgY2FuIGluaXRpYWxpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo2NgogICAgLy8gc2VsZi5hZG1pbi52YWx1ZSA9IFR4bi5zZW5kZXIuYnl0ZXMKICAgIGJ5dGVjXzMgLy8gImFkbWluIgogICAgdHhuIFNlbmRlcgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo2NwogICAgLy8gc2VsZi5vcmFjbGVfYWRkcmVzcy52YWx1ZSA9IG9yYWNsZV9hZGRyZXNzCiAgICBieXRlYyAxMiAvLyAib3JhY2xlX2FkZHJlc3MiCiAgICBmcmFtZV9kaWcgLTMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NjgKICAgIC8vIHNlbGYudG9rZW5pemF0aW9uX2FkZHJlc3MudmFsdWUgPSB0b2tlbml6YXRpb25fYWRkcmVzcwogICAgYnl0ZWMgMTMgLy8gInRva2VuaXphdGlvbl9hZGRyZXNzIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjY5CiAgICAvLyBzZWxmLmFtbV9hZGRyZXNzLnZhbHVlID0gYW1tX2FkZHJlc3MKICAgIGJ5dGVjIDE0IC8vICJhbW1fYWRkcmVzcyIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo3MAogICAgLy8gc2VsZi5jb252ZXJzaW9uX2ZlZS52YWx1ZSA9IFVJbnQ2NCgzMCkgICMgMC4zJQogICAgYnl0ZWNfMSAvLyAiY29udmVyc2lvbl9mZWUiCiAgICBwdXNoaW50IDMwIC8vIDMwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjcxCiAgICAvLyBzZWxmLmlzX3BhdXNlZC52YWx1ZSA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgNCAvLyAiaXNfcGF1c2VkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NzIKICAgIC8vIHNlbGYudG90YWxfY29udmVyc2lvbnMudmFsdWUgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDkgLy8gInRvdGFsX2NvbnZlcnNpb25zIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NzQKICAgIC8vIGxvZyhiIllUQXV0b0NvbnZlcnRlciBpbml0aWFsaXplZCIpCiAgICBwdXNoYnl0ZXMgMHg1OTU0NDE3NTc0NmY0MzZmNmU3NjY1NzI3NDY1NzIyMDY5NmU2OTc0Njk2MTZjNjk3YTY1NjQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5Ojc1CiAgICAvLyByZXR1cm4gU3RyaW5nKCJBdXRvIGNvbnZlcnRlciBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkiKQogICAgcHVzaGJ5dGVzICJBdXRvIGNvbnZlcnRlciBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmNvbmZpZ3VyZV9jb252ZXJzaW9uKGVuYWJsZWQ6IHVpbnQ2NCwgdGhyZXNob2xkX3ByaWNlOiB1aW50NjQsIG1hdHVyaXR5OiB1aW50NjQpIC0+IGJ5dGVzOgpjb25maWd1cmVfY29udmVyc2lvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo3Ny04MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICAvLyBkZWYgY29uZmlndXJlX2NvbnZlcnNpb24oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBlbmFibGVkOiBVSW50NjQsCiAgICAvLyAgICAgdGhyZXNob2xkX3ByaWNlOiBVSW50NjQsCiAgICAvLyAgICAgbWF0dXJpdHk6IFVJbnQ2NCwKICAgIC8vICkgLT4gU3RyaW5nOgogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6ODUKICAgIC8vIGFzc2VydCB0aHJlc2hvbGRfcHJpY2UgPiBVSW50NjQoMCksICJUaHJlc2hvbGQgcHJpY2UgbXVzdCBiZSBwb3NpdGl2ZSIKICAgIGZyYW1lX2RpZyAtMgogICAgYXNzZXJ0IC8vIFRocmVzaG9sZCBwcmljZSBtdXN0IGJlIHBvc2l0aXZlCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6ODYKICAgIC8vIGFzc2VydCBtYXR1cml0eSA+IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wLCAiTWF0dXJpdHkgbXVzdCBiZSBpbiBmdXR1cmUiCiAgICBmcmFtZV9kaWcgLTEKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgID4KICAgIGFzc2VydCAvLyBNYXR1cml0eSBtdXN0IGJlIGluIGZ1dHVyZQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5Ojg4CiAgICAvLyBzZWxmLmNvbnZlcnNpb25fZW5hYmxlZFtUeG4uc2VuZGVyXSA9IGVuYWJsZWQKICAgIHR4biBTZW5kZXIKICAgIGJ5dGVjIDUgLy8gImNvbnZlcnNpb25fZW5hYmxlZCIKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5Ojg5CiAgICAvLyBzZWxmLnRocmVzaG9sZF9wcmljZVtUeG4uc2VuZGVyXSA9IHRocmVzaG9sZF9wcmljZQogICAgdHhuIFNlbmRlcgogICAgYnl0ZWMgNiAvLyAidGhyZXNob2xkX3ByaWNlIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6OTAKICAgIC8vIHNlbGYudXNlcl9tYXR1cml0eVtUeG4uc2VuZGVyXSA9IG1hdHVyaXR5CiAgICB0eG4gU2VuZGVyCiAgICBieXRlYyAxMCAvLyAidXNlcl9tYXR1cml0eSIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjkxCiAgICAvLyBzZWxmLmNvbnZlcnNpb25fZXhlY3V0ZWRbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkgICMgUmVzZXQgZXhlY3V0aW9uIHN0YXR1cwogICAgdHhuIFNlbmRlcgogICAgYnl0ZWMgNyAvLyAiY29udmVyc2lvbl9leGVjdXRlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6OTMKICAgIC8vIGxvZyhiIkNvbnZlcnNpb24gY29uZmlndXJlZCAtIEVuYWJsZWQ6ICIgKyBvcC5pdG9iKGVuYWJsZWQpICsgYiIgVGhyZXNob2xkOiAiICsgb3AuaXRvYih0aHJlc2hvbGRfcHJpY2UpKQogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg0MzZmNmU3NjY1NzI3MzY5NmY2ZTIwNjM2ZjZlNjY2OTY3NzU3MjY1NjQyMDJkMjA0NTZlNjE2MjZjNjU2NDNhMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4MjA1NDY4NzI2NTczNjg2ZjZjNjQzYTIwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo5NAogICAgLy8gcmV0dXJuIFN0cmluZygiQ29udmVyc2lvbiBjb25maWd1cmVkIHN1Y2Nlc3NmdWxseSIpCiAgICBwdXNoYnl0ZXMgIkNvbnZlcnNpb24gY29uZmlndXJlZCBzdWNjZXNzZnVsbHkiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmRlcG9zaXRfeXRfdG9rZW5zKGFtb3VudDogdWludDY0KSAtPiBieXRlczoKZGVwb3NpdF95dF90b2tlbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6OTYtOTcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIGRlcG9zaXRfeXRfdG9rZW5zKHNlbGYsIGFtb3VudDogVUludDY0KSAtPiBTdHJpbmc6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo5OQogICAgLy8gYXNzZXJ0IGFtb3VudCA+IFVJbnQ2NCgwKSwgIkFtb3VudCBtdXN0IGJlIHBvc2l0aXZlIgogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NlcnQgLy8gQW1vdW50IG11c3QgYmUgcG9zaXRpdmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxMDEKICAgIC8vIHNlbGYueXRfYmFsYW5jZVtUeG4uc2VuZGVyXSA9IHNlbGYueXRfYmFsYW5jZVtUeG4uc2VuZGVyXSArIGFtb3VudAogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInl0X2JhbGFuY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi55dF9iYWxhbmNlIGV4aXN0cyBmb3IgYWNjb3VudAogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICB0eG4gU2VuZGVyCiAgICBieXRlY18yIC8vICJ5dF9iYWxhbmNlIgogICAgdW5jb3ZlciAyCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTAzCiAgICAvLyBsb2coYiJZVCB0b2tlbnMgZGVwb3NpdGVkIC0gQW1vdW50OiAiICsgb3AuaXRvYihhbW91bnQpKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg1OTU0MjA3NDZmNmI2NTZlNzMyMDY0NjU3MDZmNzM2OTc0NjU2NDIwMmQyMDQxNmQ2Zjc1NmU3NDNhMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTA0CiAgICAvLyByZXR1cm4gU3RyaW5nKCJZVCB0b2tlbnMgZGVwb3NpdGVkIHN1Y2Nlc3NmdWxseSIpCiAgICBwdXNoYnl0ZXMgIllUIHRva2VucyBkZXBvc2l0ZWQgc3VjY2Vzc2Z1bGx5IgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5leGVjdXRlX2NvbnZlcnNpb24odXNlcjogYnl0ZXMsIG1pbl9wdF9hbW91bnQ6IHVpbnQ2NCwgZGVhZGxpbmU6IHVpbnQ2NCkgLT4gYnl0ZXM6CmV4ZWN1dGVfY29udmVyc2lvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxMDYtMTEyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBleGVjdXRlX2NvbnZlcnNpb24oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB1c2VyOiBCeXRlcywKICAgIC8vICAgICBtaW5fcHRfYW1vdW50OiBVSW50NjQsCiAgICAvLyAgICAgZGVhZGxpbmU6IFVJbnQ2NCwKICAgIC8vICkgLT4gU3RyaW5nOgogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTE0CiAgICAvLyBhc3NlcnQgc2VsZi5pc19wYXVzZWQudmFsdWUgPT0gVUludDY0KDApLCAiQ29udmVydGVyIGlzIHBhdXNlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJpc19wYXVzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfcGF1c2VkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIENvbnZlcnRlciBpcyBwYXVzZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxMTUKICAgIC8vIGFzc2VydCBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCA8PSBkZWFkbGluZSwgIlRyYW5zYWN0aW9uIGV4cGlyZWQiCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBmcmFtZV9kaWcgLTEKICAgIDw9CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gZXhwaXJlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjEyMAogICAgLy8gYXNzZXJ0IHNlbGYuY29udmVyc2lvbl9lbmFibGVkW1R4bi5zZW5kZXJdID09IFVJbnQ2NCgxKSwgIkNvbnZlcnNpb24gbm90IGVuYWJsZWQiCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAiY29udmVyc2lvbl9lbmFibGVkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY29udmVyc2lvbl9lbmFibGVkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gQ29udmVyc2lvbiBub3QgZW5hYmxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjEyMQogICAgLy8gYXNzZXJ0IHNlbGYuY29udmVyc2lvbl9leGVjdXRlZFtUeG4uc2VuZGVyXSA9PSBVSW50NjQoMCksICJDb252ZXJzaW9uIGFscmVhZHkgZXhlY3V0ZWQiCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAiY29udmVyc2lvbl9leGVjdXRlZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZXhlY3V0ZWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAhCiAgICBhc3NlcnQgLy8gQ29udmVyc2lvbiBhbHJlYWR5IGV4ZWN1dGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTIzLTEyNQogICAgLy8gIyBDaGVjayBpZiB0aHJlc2hvbGQgaXMgcmVhY2hlZCAoc2ltcGxpZmllZCAtIHdvdWxkIGNhbGwgb3JhY2xlIGNvbnRyYWN0KQogICAgLy8gIyBGb3IgZGVtbywgYXNzdW1lIHRocmVzaG9sZCBpcyByZWFjaGVkIGlmIHRocmVzaG9sZF9wcmljZSA+IDAKICAgIC8vIHVzZXJfdGhyZXNob2xkID0gc2VsZi50aHJlc2hvbGRfcHJpY2VbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJ0aHJlc2hvbGRfcHJpY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50aHJlc2hvbGRfcHJpY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTI2CiAgICAvLyBhc3NlcnQgdXNlcl90aHJlc2hvbGQgPiBVSW50NjQoMCksICJUaHJlc2hvbGQgbm90IHJlYWNoZWQiCiAgICBhc3NlcnQgLy8gVGhyZXNob2xkIG5vdCByZWFjaGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTI4LTEyOQogICAgLy8gIyBDaGVjayBZVCBiYWxhbmNlCiAgICAvLyB1c2VyX3l0X2JhbGFuY2UgPSBzZWxmLnl0X2JhbGFuY2VbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ5dF9iYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYueXRfYmFsYW5jZSBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxMzAKICAgIC8vIGFzc2VydCB1c2VyX3l0X2JhbGFuY2UgPiBVSW50NjQoMCksICJObyBZVCB0b2tlbnMgdG8gY29udmVydCIKICAgIGR1cAogICAgYXNzZXJ0IC8vIE5vIFlUIHRva2VucyB0byBjb252ZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTMyLTEzMwogICAgLy8gIyBDYWxjdWxhdGUgY29udmVyc2lvbiBmZWUKICAgIC8vIGZlZV9hbW91bnQgPSAodXNlcl95dF9iYWxhbmNlICogc2VsZi5jb252ZXJzaW9uX2ZlZS52YWx1ZSkgLy8gc2VsZi5mZWVfZGVub21pbmF0b3IKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJjb252ZXJzaW9uX2ZlZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jb252ZXJzaW9uX2ZlZSBleGlzdHMKICAgIGRpZyAxCiAgICAqCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTEgLy8gImZlZV9kZW5vbWluYXRvciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5mZWVfZGVub21pbmF0b3IgZXhpc3RzCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTM0CiAgICAvLyBjb252ZXJzaW9uX2Ftb3VudCA9IHVzZXJfeXRfYmFsYW5jZSAtIGZlZV9hbW91bnQKICAgIGRpZyAxCiAgICBzd2FwCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjg3LTI4OAogICAgLy8gIyBTaW11bGF0ZSBzbGlwcGFnZSBhbmQgbWFya2V0IGltcGFjdAogICAgLy8gc2xpcHBhZ2VfZmFjdG9yID0gVUludDY0KDk5NTApICAjIDAuNSUgc2xpcHBhZ2UKICAgIHB1c2hpbnQgOTk1MCAvLyA5OTUwCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjg5CiAgICAvLyBtYXJrZXRfcmF0ZSA9IChhbW91bnQgKiBzbGlwcGFnZV9mYWN0b3IpIC8vIFVJbnQ2NCgxMDAwMCkKICAgICoKICAgIGludGNfMiAvLyAxMDAwMAogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI5MQogICAgLy8gYXNzZXJ0IG1hcmtldF9yYXRlID49IG1pbl9vdXRwdXQsICJJbnN1ZmZpY2llbnQgb3V0cHV0IGFtb3VudCIKICAgIGR1cAogICAgZnJhbWVfZGlnIC0yCiAgICA+PQogICAgYXNzZXJ0IC8vIEluc3VmZmljaWVudCBvdXRwdXQgYW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTM5LTE0MAogICAgLy8gIyBVcGRhdGUgYmFsYW5jZXMKICAgIC8vIHNlbGYueXRfYmFsYW5jZVtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgwKSAgIyBBbGwgWVQgdG9rZW5zIGNvbnZlcnRlZAogICAgdHhuIFNlbmRlcgogICAgYnl0ZWNfMiAvLyAieXRfYmFsYW5jZSIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTQxCiAgICAvLyBzZWxmLnB0X2JhbGFuY2VbVHhuLnNlbmRlcl0gPSBzZWxmLnB0X2JhbGFuY2VbVHhuLnNlbmRlcl0gKyByZWNlaXZlZF9wdAogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDggLy8gInB0X2JhbGFuY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wdF9iYWxhbmNlIGV4aXN0cyBmb3IgYWNjb3VudAogICAgZGlnIDEKICAgICsKICAgIHR4biBTZW5kZXIKICAgIGJ5dGVjIDggLy8gInB0X2JhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNDIKICAgIC8vIHNlbGYuY29udmVyc2lvbl9leGVjdXRlZFtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgxKQogICAgdHhuIFNlbmRlcgogICAgYnl0ZWMgNyAvLyAiY29udmVyc2lvbl9leGVjdXRlZCIKICAgIGludGNfMSAvLyAxCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTQ0LTE0NQogICAgLy8gIyBVcGRhdGUgZ2xvYmFsIHN0YXRzCiAgICAvLyBzZWxmLnRvdGFsX2NvbnZlcnNpb25zLnZhbHVlID0gc2VsZi50b3RhbF9jb252ZXJzaW9ucy52YWx1ZSArIFVJbnQ2NCgxKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gInRvdGFsX2NvbnZlcnNpb25zIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2NvbnZlcnNpb25zIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ5dGVjIDkgLy8gInRvdGFsX2NvbnZlcnNpb25zIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNDcKICAgIC8vIGxvZyhiIkNvbnZlcnNpb24gZXhlY3V0ZWQgLSBZVDogIiArIG9wLml0b2IodXNlcl95dF9iYWxhbmNlKSArIGIiIFBUOiAiICsgb3AuaXRvYihyZWNlaXZlZF9wdCkpCiAgICBzd2FwCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg0MzZmNmU3NjY1NzI3MzY5NmY2ZTIwNjU3ODY1NjM3NTc0NjU2NDIwMmQyMDU5NTQzYTIwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDIwNTA1NDNhMjAKICAgIGNvbmNhdAogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNDgKICAgIC8vIHJldHVybiBTdHJpbmcoIkNvbnZlcnNpb24gZXhlY3V0ZWQgc3VjY2Vzc2Z1bGx5IikKICAgIHB1c2hieXRlcyAiQ29udmVyc2lvbiBleGVjdXRlZCBzdWNjZXNzZnVsbHkiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmNhbl9leGVjdXRlX2NvbnZlcnNpb24odXNlcjogYnl0ZXMpIC0+IHVpbnQ2NDoKY2FuX2V4ZWN1dGVfY29udmVyc2lvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNTAtMTUxCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBjYW5fZXhlY3V0ZV9jb252ZXJzaW9uKHNlbGYsIHVzZXI6IEJ5dGVzKSAtPiBVSW50NjQ6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNTMtMTU0CiAgICAvLyAjIFNpbXBsaWZpZWQgY2hlY2sgdXNpbmcgc2VuZGVyJ3MgZGF0YQogICAgLy8gaWYgc2VsZi5jb252ZXJzaW9uX2VuYWJsZWRbVHhuLnNlbmRlcl0gPT0gVUludDY0KDApOgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImNvbnZlcnNpb25fZW5hYmxlZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZW5hYmxlZCBleGlzdHMgZm9yIGFjY291bnQKICAgIGJueiBjYW5fZXhlY3V0ZV9jb252ZXJzaW9uX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE1NQogICAgLy8gcmV0dXJuIFVJbnQ2NCgwKSAgIyBOb3QgZW5hYmxlZAogICAgaW50Y18wIC8vIDAKICAgIHJldHN1YgoKY2FuX2V4ZWN1dGVfY29udmVyc2lvbl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTU3CiAgICAvLyBpZiBzZWxmLmNvbnZlcnNpb25fZXhlY3V0ZWRbVHhuLnNlbmRlcl0gPT0gVUludDY0KDEpOgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gImNvbnZlcnNpb25fZXhlY3V0ZWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jb252ZXJzaW9uX2V4ZWN1dGVkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBieiBjYW5fZXhlY3V0ZV9jb252ZXJzaW9uX2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE1OAogICAgLy8gcmV0dXJuIFVJbnQ2NCgwKSAgIyBBbHJlYWR5IGV4ZWN1dGVkCiAgICBpbnRjXzAgLy8gMAogICAgcmV0c3ViCgpjYW5fZXhlY3V0ZV9jb252ZXJzaW9uX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNjAKICAgIC8vIGlmIHNlbGYueXRfYmFsYW5jZVtUeG4uc2VuZGVyXSA9PSBVSW50NjQoMCk6CiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAieXRfYmFsYW5jZSIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnl0X2JhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICBibnogY2FuX2V4ZWN1dGVfY29udmVyc2lvbl9hZnRlcl9pZl9lbHNlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNjEKICAgIC8vIHJldHVybiBVSW50NjQoMCkgICMgTm8gWVQgdG9rZW5zCiAgICBpbnRjXzAgLy8gMAogICAgcmV0c3ViCgpjYW5fZXhlY3V0ZV9jb252ZXJzaW9uX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNjMKICAgIC8vIGlmIHNlbGYudGhyZXNob2xkX3ByaWNlW1R4bi5zZW5kZXJdID09IFVJbnQ2NCgwKToKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJ0aHJlc2hvbGRfcHJpY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50aHJlc2hvbGRfcHJpY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICBibnogY2FuX2V4ZWN1dGVfY29udmVyc2lvbl9hZnRlcl9pZl9lbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNjQKICAgIC8vIHJldHVybiBVSW50NjQoMCkgICMgTm8gdGhyZXNob2xkIHNldAogICAgaW50Y18wIC8vIDAKICAgIHJldHN1YgoKY2FuX2V4ZWN1dGVfY29udmVyc2lvbl9hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTY2LTE2NwogICAgLy8gIyBJbiBwcm9kdWN0aW9uLCB3b3VsZCBjaGVjayBvcmFjbGUgZm9yIGFjdHVhbCB0aHJlc2hvbGQgc3RhdHVzCiAgICAvLyByZXR1cm4gVUludDY0KDEpICAjIENhbiBleGVjdXRlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5nZXRfdXNlcl9jb25maWcoKSAtPiBieXRlczoKZ2V0X3VzZXJfY29uZmlnOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE3MwogICAgLy8gYXJjNC5VSW50NjQoc2VsZi5jb252ZXJzaW9uX2VuYWJsZWRbVHhuLnNlbmRlcl0pLAogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImNvbnZlcnNpb25fZW5hYmxlZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZW5hYmxlZCBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNzQKICAgIC8vIGFyYzQuVUludDY0KHNlbGYudGhyZXNob2xkX3ByaWNlW1R4bi5zZW5kZXJdKSwKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJ0aHJlc2hvbGRfcHJpY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50aHJlc2hvbGRfcHJpY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTc1CiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLnVzZXJfbWF0dXJpdHlbVHhuLnNlbmRlcl0pLAogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vICJ1c2VyX21hdHVyaXR5IgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudXNlcl9tYXR1cml0eSBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNzYKICAgIC8vIGFyYzQuVUludDY0KHNlbGYuY29udmVyc2lvbl9leGVjdXRlZFtUeG4uc2VuZGVyXSkKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJjb252ZXJzaW9uX2V4ZWN1dGVkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY29udmVyc2lvbl9leGVjdXRlZCBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNzItMTc3CiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoCiAgICAvLyAgICAgYXJjNC5VSW50NjQoc2VsZi5jb252ZXJzaW9uX2VuYWJsZWRbVHhuLnNlbmRlcl0pLAogICAgLy8gICAgIGFyYzQuVUludDY0KHNlbGYudGhyZXNob2xkX3ByaWNlW1R4bi5zZW5kZXJdKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLnVzZXJfbWF0dXJpdHlbVHhuLnNlbmRlcl0pLAogICAgLy8gICAgIGFyYzQuVUludDY0KHNlbGYuY29udmVyc2lvbl9leGVjdXRlZFtUeG4uc2VuZGVyXSkKICAgIC8vICkpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmdldF91c2VyX2JhbGFuY2VzKCkgLT4gYnl0ZXM6CmdldF91c2VyX2JhbGFuY2VzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE4MwogICAgLy8gYXJjNC5VSW50NjQoc2VsZi55dF9iYWxhbmNlW1R4bi5zZW5kZXJdKSwKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ5dF9iYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYueXRfYmFsYW5jZSBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxODQKICAgIC8vIGFyYzQuVUludDY0KHNlbGYucHRfYmFsYW5jZVtUeG4uc2VuZGVyXSkKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vICJwdF9iYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucHRfYmFsYW5jZSBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxODItMTg1CiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoCiAgICAvLyAgICAgYXJjNC5VSW50NjQoc2VsZi55dF9iYWxhbmNlW1R4bi5zZW5kZXJdKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLnB0X2JhbGFuY2VbVHhuLnNlbmRlcl0pCiAgICAvLyApKQogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmdldF9jb252ZXJzaW9uX2luZm8oKSAtPiBieXRlczoKZ2V0X2NvbnZlcnNpb25faW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxOTEKICAgIC8vIGFyYzQuVUludDY0KHNlbGYuY29udmVyc2lvbl9mZWUudmFsdWUpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImNvbnZlcnNpb25fZmVlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZmVlIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE5MgogICAgLy8gYXJjNC5VSW50NjQoc2VsZi50b3RhbF9jb252ZXJzaW9ucy52YWx1ZSksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAidG90YWxfY29udmVyc2lvbnMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudG90YWxfY29udmVyc2lvbnMgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTkzCiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLmlzX3BhdXNlZC52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJpc19wYXVzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfcGF1c2VkIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE5MC0xOTQKICAgIC8vIHJldHVybiBhcmM0LlR1cGxlKCgKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLmNvbnZlcnNpb25fZmVlLnZhbHVlKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLnRvdGFsX2NvbnZlcnNpb25zLnZhbHVlKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLmlzX3BhdXNlZC52YWx1ZSkKICAgIC8vICkpCiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5jYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXQoeXRfYW1vdW50OiB1aW50NjQpIC0+IGJ5dGVzOgpjYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTk2LTE5NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgY2FsY3VsYXRlX2NvbnZlcnNpb25fb3V0cHV0KHNlbGYsIHl0X2Ftb3VudDogVUludDY0KSAtPiBhcmM0LlR1cGxlW2FyYzQuVUludDY0LCBhcmM0LlVJbnQ2NF06CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxOTkKICAgIC8vIGlmIHl0X2Ftb3VudCA9PSBVSW50NjQoMCk6CiAgICBmcmFtZV9kaWcgLTEKICAgIGJueiBjYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXRfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjAwCiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoYXJjNC5VSW50NjQoMCksIGFyYzQuVUludDY0KDApKSkKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICByZXRzdWIKCmNhbGN1bGF0ZV9jb252ZXJzaW9uX291dHB1dF9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjAyCiAgICAvLyBmZWVfYW1vdW50ID0gKHl0X2Ftb3VudCAqIHNlbGYuY29udmVyc2lvbl9mZWUudmFsdWUpIC8vIHNlbGYuZmVlX2Rlbm9taW5hdG9yCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAiY29udmVyc2lvbl9mZWUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY29udmVyc2lvbl9mZWUgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgICoKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX2Rlbm9taW5hdG9yIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9kZW5vbWluYXRvciBleGlzdHMKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMDMKICAgIC8vIGNvbnZlcnNpb25fYW1vdW50ID0geXRfYW1vdW50IC0gZmVlX2Ftb3VudAogICAgZnJhbWVfZGlnIC0xCiAgICBkaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIwNS0yMDYKICAgIC8vICMgU2ltcGxpZmllZCBjb252ZXJzaW9uIHJhdGUgKDE6MSBtaW51cyBzbGlwcGFnZSkKICAgIC8vIHNsaXBwYWdlX2Ftb3VudCA9IChjb252ZXJzaW9uX2Ftb3VudCAqIFVJbnQ2NCg1MCkpIC8vIFVJbnQ2NCgxMDAwMCkgICMgMC41JSBzbGlwcGFnZQogICAgZHVwCiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICAqCiAgICBpbnRjXzIgLy8gMTAwMDAKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMDcKICAgIC8vIGV4cGVjdGVkX3B0ID0gY29udmVyc2lvbl9hbW91bnQgLSBzbGlwcGFnZV9hbW91bnQKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMDkKICAgIC8vIHJldHVybiBhcmM0LlR1cGxlKChhcmM0LlVJbnQ2NChleHBlY3RlZF9wdCksIGFyYzQuVUludDY0KGZlZV9hbW91bnQpKSkKICAgIGl0b2IKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5hZGRfbWF0dXJpdHkobWF0dXJpdHk6IHVpbnQ2NCkgLT4gYnl0ZXM6CmFkZF9tYXR1cml0eToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMTEtMjEyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBhZGRfbWF0dXJpdHkoc2VsZiwgbWF0dXJpdHk6IFVJbnQ2NCkgLT4gU3RyaW5nOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjE0CiAgICAvLyBhc3NlcnQgbWF0dXJpdHkgPiBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCwgIk1hdHVyaXR5IG11c3QgYmUgaW4gZnV0dXJlIgogICAgZnJhbWVfZGlnIC0xCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICA+CiAgICBhc3NlcnQgLy8gTWF0dXJpdHkgbXVzdCBiZSBpbiBmdXR1cmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMTYtMjE3CiAgICAvLyAjIEZvciBzaW1wbGljaXR5LCBqdXN0IHVwZGF0ZSB1c2VyJ3MgbWF0dXJpdHkKICAgIC8vIHNlbGYudXNlcl9tYXR1cml0eVtUeG4uc2VuZGVyXSA9IG1hdHVyaXR5CiAgICB0eG4gU2VuZGVyCiAgICBieXRlYyAxMCAvLyAidXNlcl9tYXR1cml0eSIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIxOQogICAgLy8gbG9nKGIiTWF0dXJpdHkgYWRkZWQgLSBWYWx1ZTogIiArIG9wLml0b2IobWF0dXJpdHkpKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg0ZDYxNzQ3NTcyNjk3NDc5MjA2MTY0NjQ2NTY0MjAyZDIwNTY2MTZjNzU2NTNhMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjIwCiAgICAvLyByZXR1cm4gU3RyaW5nKCJNYXR1cml0eSBhZGRlZCBzdWNjZXNzZnVsbHkiKQogICAgcHVzaGJ5dGVzICJNYXR1cml0eSBhZGRlZCBzdWNjZXNzZnVsbHkiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLnJlbW92ZV9tYXR1cml0eSgpIC0+IGJ5dGVzOgpyZW1vdmVfbWF0dXJpdHk6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjI1CiAgICAvLyBzZWxmLnVzZXJfbWF0dXJpdHlbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGVjIDEwIC8vICJ1c2VyX21hdHVyaXR5IgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMjcKICAgIC8vIGxvZyhiIk1hdHVyaXR5IHJlbW92ZWQiKQogICAgcHVzaGJ5dGVzIDB4NGQ2MTc0NzU3MjY5NzQ3OTIwNzI2NTZkNmY3NjY1NjQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIyOAogICAgLy8gcmV0dXJuIFN0cmluZygiTWF0dXJpdHkgcmVtb3ZlZCBzdWNjZXNzZnVsbHkiKQogICAgcHVzaGJ5dGVzICJNYXR1cml0eSByZW1vdmVkIHN1Y2Nlc3NmdWxseSIKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIuc2V0X2NvbnZlcnNpb25fZmVlKG5ld19mZWU6IHVpbnQ2NCkgLT4gYnl0ZXM6CnNldF9jb252ZXJzaW9uX2ZlZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMzAtMjMxCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBzZXRfY29udmVyc2lvbl9mZWUoc2VsZiwgbmV3X2ZlZTogVUludDY0KSAtPiBTdHJpbmc6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMzMKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyLmJ5dGVzID09IHNlbGYuYWRtaW4udmFsdWUsICJPbmx5IGFkbWluIGNhbiBzZXQgZmVlIgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gImFkbWluIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFkbWluIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IGFkbWluIGNhbiBzZXQgZmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjM0CiAgICAvLyBhc3NlcnQgbmV3X2ZlZSA8PSBVSW50NjQoMTAwMCksICJGZWUgdG9vIGhpZ2ggKG1heCAxMCUpIgogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDEwMDAgLy8gMTAwMAogICAgPD0KICAgIGFzc2VydCAvLyBGZWUgdG9vIGhpZ2ggKG1heCAxMCUpCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjM2CiAgICAvLyBvbGRfZmVlID0gc2VsZi5jb252ZXJzaW9uX2ZlZS52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImNvbnZlcnNpb25fZmVlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZmVlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIzNwogICAgLy8gc2VsZi5jb252ZXJzaW9uX2ZlZS52YWx1ZSA9IG5ld19mZWUKICAgIGJ5dGVjXzEgLy8gImNvbnZlcnNpb25fZmVlIgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIzOQogICAgLy8gbG9nKGIiQ29udmVyc2lvbiBmZWUgdXBkYXRlZCAtIE9sZDogIiArIG9wLml0b2Iob2xkX2ZlZSkgKyBiIiBOZXc6ICIgKyBvcC5pdG9iKG5ld19mZWUpKQogICAgaXRvYgogICAgcHVzaGJ5dGVzIDB4NDM2ZjZlNzY2NTcyNzM2OTZmNmUyMDY2NjU2NTIwNzU3MDY0NjE3NDY1NjQyMDJkMjA0ZjZjNjQzYTIwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDIwNGU2NTc3M2EyMAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjQwCiAgICAvLyByZXR1cm4gU3RyaW5nKCJDb252ZXJzaW9uIGZlZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseSIpCiAgICBwdXNoYnl0ZXMgIkNvbnZlcnNpb24gZmVlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5wYXVzZV9jb252ZXJ0ZXIoKSAtPiBieXRlczoKcGF1c2VfY29udmVydGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI0NQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIuYnl0ZXMgPT0gc2VsZi5hZG1pbi52YWx1ZSwgIk9ubHkgYWRtaW4gY2FuIHBhdXNlIgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gImFkbWluIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFkbWluIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IGFkbWluIGNhbiBwYXVzZQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI0NgogICAgLy8gc2VsZi5pc19wYXVzZWQudmFsdWUgPSBVSW50NjQoMSkKICAgIGJ5dGVjIDQgLy8gImlzX3BhdXNlZCIKICAgIGludGNfMSAvLyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI0OAogICAgLy8gbG9nKGIiQ29udmVydGVyIHBhdXNlZCIpCiAgICBieXRlYyAxNSAvLyAweDQzNmY2ZTc2NjU3Mjc0NjU3MjIwNzA2MTc1NzM2NTY0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNDkKICAgIC8vIHJldHVybiBTdHJpbmcoIkNvbnZlcnRlciBwYXVzZWQiKQogICAgYnl0ZWMgMTUgLy8gIkNvbnZlcnRlciBwYXVzZWQiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLnVucGF1c2VfY29udmVydGVyKCkgLT4gYnl0ZXM6CnVucGF1c2VfY29udmVydGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI1NAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIuYnl0ZXMgPT0gc2VsZi5hZG1pbi52YWx1ZSwgIk9ubHkgYWRtaW4gY2FuIHVucGF1c2UiCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiYWRtaW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYWRtaW4gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgYWRtaW4gY2FuIHVucGF1c2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNTUKICAgIC8vIHNlbGYuaXNfcGF1c2VkLnZhbHVlID0gVUludDY0KDApCiAgICBieXRlYyA0IC8vICJpc19wYXVzZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNTcKICAgIC8vIGxvZyhiIkNvbnZlcnRlciB1bnBhdXNlZCIpCiAgICBieXRlYyAxNiAvLyAweDQzNmY2ZTc2NjU3Mjc0NjU3MjIwNzU2ZTcwNjE3NTczNjU2NAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjU4CiAgICAvLyByZXR1cm4gU3RyaW5nKCJDb252ZXJ0ZXIgdW5wYXVzZWQiKQogICAgYnl0ZWMgMTYgLy8gIkNvbnZlcnRlciB1bnBhdXNlZCIKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIuZW1lcmdlbmN5X2Rpc2FibGVfY29udmVyc2lvbigpIC0+IGJ5dGVzOgplbWVyZ2VuY3lfZGlzYWJsZV9jb252ZXJzaW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI2MwogICAgLy8gc2VsZi5jb252ZXJzaW9uX2VuYWJsZWRbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGVjIDUgLy8gImNvbnZlcnNpb25fZW5hYmxlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjY1CiAgICAvLyBsb2coYiJDb252ZXJzaW9uIGVtZXJnZW5jeSBkaXNhYmxlZCIpCiAgICBwdXNoYnl0ZXMgMHg0MzZmNmU3NjY1NzI3MzY5NmY2ZTIwNjU2ZDY1NzI2NzY1NmU2Mzc5MjA2NDY5NzM2MTYyNmM2NTY0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNjYKICAgIC8vIHJldHVybiBTdHJpbmcoIkNvbnZlcnNpb24gZGlzYWJsZWQgZm9yIGVtZXJnZW5jeSIpCiAgICBwdXNoYnl0ZXMgIkNvbnZlcnNpb24gZGlzYWJsZWQgZm9yIGVtZXJnZW5jeSIKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIud2l0aGRyYXdfcHRfdG9rZW5zKGFtb3VudDogdWludDY0KSAtPiBieXRlczoKd2l0aGRyYXdfcHRfdG9rZW5zOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI2OC0yNjkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIHdpdGhkcmF3X3B0X3Rva2VucyhzZWxmLCBhbW91bnQ6IFVJbnQ2NCkgLT4gU3RyaW5nOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjcxCiAgICAvLyBhc3NlcnQgYW1vdW50ID4gVUludDY0KDApLCAiQW1vdW50IG11c3QgYmUgcG9zaXRpdmUiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2VydCAvLyBBbW91bnQgbXVzdCBiZSBwb3NpdGl2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI3MwogICAgLy8gY3VycmVudF9wdF9iYWxhbmNlID0gc2VsZi5wdF9iYWxhbmNlW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOCAvLyAicHRfYmFsYW5jZSIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnB0X2JhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjc0CiAgICAvLyBhc3NlcnQgY3VycmVudF9wdF9iYWxhbmNlID49IGFtb3VudCwgIkluc3VmZmljaWVudCBQVCBiYWxhbmNlIgogICAgZHVwCiAgICBmcmFtZV9kaWcgLTEKICAgID49CiAgICBhc3NlcnQgLy8gSW5zdWZmaWNpZW50IFBUIGJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNzYKICAgIC8vIHNlbGYucHRfYmFsYW5jZVtUeG4uc2VuZGVyXSA9IGN1cnJlbnRfcHRfYmFsYW5jZSAtIGFtb3VudAogICAgZnJhbWVfZGlnIC0xCiAgICAtCiAgICB0eG4gU2VuZGVyCiAgICBieXRlYyA4IC8vICJwdF9iYWxhbmNlIgogICAgdW5jb3ZlciAyCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjc4CiAgICAvLyBsb2coYiJQVCB0b2tlbnMgd2l0aGRyYXduIC0gQW1vdW50OiAiICsgb3AuaXRvYihhbW91bnQpKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg1MDU0MjA3NDZmNmI2NTZlNzMyMDc3Njk3NDY4NjQ3MjYxNzc2ZTIwMmQyMDQxNmQ2Zjc1NmU3NDNhMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjc5CiAgICAvLyByZXR1cm4gU3RyaW5nKCJQVCB0b2tlbnMgd2l0aGRyYXduIHN1Y2Nlc3NmdWxseSIpCiAgICBwdXNoYnl0ZXMgIlBUIHRva2VucyB3aXRoZHJhd24gc3VjY2Vzc2Z1bGx5IgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5nZXRfYWlfcmVjb21tZW5kYXRpb24oeXRfYW1vdW50OiB1aW50NjQsIGN1cnJlbnRfcHJpY2U6IHVpbnQ2NCkgLT4gYnl0ZXM6CmdldF9haV9yZWNvbW1lbmRhdGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyOTUtMjk2CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfYWlfcmVjb21tZW5kYXRpb24oc2VsZiwgeXRfYW1vdW50OiBVSW50NjQsIGN1cnJlbnRfcHJpY2U6IFVJbnQ2NCkgLT4gYXJjNC5UdXBsZVthcmM0LlVJbnQ2NCwgYXJjNC5TdHJpbmddOgogICAgcHJvdG8gMiAxCiAgICBwdXNoYnl0ZXMgIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyOTgKICAgIC8vIGlmIHl0X2Ftb3VudCA9PSBVSW50NjQoMCk6CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiBnZXRfYWlfcmVjb21tZW5kYXRpb25fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjk5CiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoYXJjNC5VSW50NjQoMCksIGFyYzQuU3RyaW5nKCJObyBZVCB0b2tlbnMgdG8gY29udmVydCIpKSkKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAxNzRlNmYyMDU5NTQyMDc0NmY2YjY1NmU3MzIwNzQ2ZjIwNjM2ZjZlNzY2NTcyNzQKICAgIHN3YXAKICAgIHJldHN1YgoKZ2V0X2FpX3JlY29tbWVuZGF0aW9uX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMDEKICAgIC8vIHVzZXJfdGhyZXNob2xkID0gc2VsZi50aHJlc2hvbGRfcHJpY2VbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJ0aHJlc2hvbGRfcHJpY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGhyZXNob2xkX3ByaWNlIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMwMwogICAgLy8gaWYgY3VycmVudF9wcmljZSA+PSB1c2VyX3RocmVzaG9sZDoKICAgIGZyYW1lX2RpZyAtMQogICAgPD0KICAgIGJ6IGdldF9haV9yZWNvbW1lbmRhdGlvbl9lbHNlX2JvZHlANAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMwNAogICAgLy8gcmV0dXJuIGFyYzQuVHVwbGUoKGFyYzQuVUludDY0KDEpLCBhcmM0LlN0cmluZygiUmVjb21tZW5kIGNvbnZlcnNpb24gLSB0aHJlc2hvbGQgcmVhY2hlZCIpKSkKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDEwMDBhMDAyODUyNjU2MzZmNmQ2ZDY1NmU2NDIwNjM2ZjZlNzY2NTcyNzM2OTZmNmUyMDJkMjA3NDY4NzI2NTczNjg2ZjZjNjQyMDcyNjU2MTYzNjg2NTY0CiAgICBzd2FwCiAgICByZXRzdWIKCmdldF9haV9yZWNvbW1lbmRhdGlvbl9lbHNlX2JvZHlANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMDYKICAgIC8vIHJlbWFpbmluZ191cHNpZGUgPSAoKHVzZXJfdGhyZXNob2xkIC0gY3VycmVudF9wcmljZSkgKiBVSW50NjQoMTAwKSkgLy8gY3VycmVudF9wcmljZQogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2RpZyAtMQogICAgLQogICAgcHVzaGludCAxMDAgLy8gMTAwCiAgICAqCiAgICBmcmFtZV9kaWcgLTEKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMDcKICAgIC8vIGlmIHJlbWFpbmluZ191cHNpZGUgPCBVSW50NjQoNSk6ICAjIExlc3MgdGhhbiA1JSB0byB0aHJlc2hvbGQKICAgIHB1c2hpbnQgNSAvLyA1CiAgICA8CiAgICBieiBnZXRfYWlfcmVjb21tZW5kYXRpb25fZWxzZV9ib2R5QDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMDgKICAgIC8vIHJldHVybiBhcmM0LlR1cGxlKChhcmM0LlVJbnQ2NCgxKSwgYXJjNC5TdHJpbmcoIlJlY29tbWVuZCBjb252ZXJzaW9uIC0gY2xvc2UgdG8gdGhyZXNob2xkIikpKQogICAgcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMTAwMGEwMDI5NTI2NTYzNmY2ZDZkNjU2ZTY0MjA2MzZmNmU3NjY1NzI3MzY5NmY2ZTIwMmQyMDYzNmM2ZjczNjUyMDc0NmYyMDc0Njg3MjY1NzM2ODZmNmM2NAogICAgc3dhcAogICAgcmV0c3ViCgpnZXRfYWlfcmVjb21tZW5kYXRpb25fZWxzZV9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEwCiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoYXJjNC5VSW50NjQoMCksIGFyYzQuU3RyaW5nKCJIb2xkIFlUIHRva2VucyAtIHRocmVzaG9sZCBub3QgcmVhY2hlZCIpKSkKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAyNjQ4NmY2YzY0MjA1OTU0MjA3NDZmNmI2NTZlNzMyMDJkMjA3NDY4NzI2NTczNjg2ZjZjNjQyMDZlNmY3NDIwNzI2NTYxNjM2ODY1NjQKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIudXBkYXRlX2FkZHJlc3NlcyhvcmFjbGVfYWRkcmVzczogYnl0ZXMsIHRva2VuaXphdGlvbl9hZGRyZXNzOiBieXRlcywgYW1tX2FkZHJlc3M6IGJ5dGVzKSAtPiBieXRlczoKdXBkYXRlX2FkZHJlc3NlczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMTItMzE4CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiB1cGRhdGVfYWRkcmVzc2VzKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgb3JhY2xlX2FkZHJlc3M6IEJ5dGVzLAogICAgLy8gICAgIHRva2VuaXphdGlvbl9hZGRyZXNzOiBCeXRlcywKICAgIC8vICAgICBhbW1fYWRkcmVzczogQnl0ZXMsCiAgICAvLyApIC0+IFN0cmluZzoKICAgIHByb3RvIDMgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMyMAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIuYnl0ZXMgPT0gc2VsZi5hZG1pbi52YWx1ZSwgIk9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZGRyZXNzZXMiCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiYWRtaW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYWRtaW4gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZGRyZXNzZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMjIKICAgIC8vIHNlbGYub3JhY2xlX2FkZHJlc3MudmFsdWUgPSBvcmFjbGVfYWRkcmVzcwogICAgYnl0ZWMgMTIgLy8gIm9yYWNsZV9hZGRyZXNzIgogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMyMwogICAgLy8gc2VsZi50b2tlbml6YXRpb25fYWRkcmVzcy52YWx1ZSA9IHRva2VuaXphdGlvbl9hZGRyZXNzCiAgICBieXRlYyAxMyAvLyAidG9rZW5pemF0aW9uX2FkZHJlc3MiCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzI0CiAgICAvLyBzZWxmLmFtbV9hZGRyZXNzLnZhbHVlID0gYW1tX2FkZHJlc3MKICAgIGJ5dGVjIDE0IC8vICJhbW1fYWRkcmVzcyIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMjYKICAgIC8vIGxvZyhiIkNvbnRyYWN0IGFkZHJlc3NlcyB1cGRhdGVkIikKICAgIHB1c2hieXRlcyAweDQzNmY2ZTc0NzI2MTYzNzQyMDYxNjQ2NDcyNjU3MzczNjU3MzIwNzU3MDY0NjE3NDY1NjQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMyNwogICAgLy8gcmV0dXJuIFN0cmluZygiQ29udHJhY3QgYWRkcmVzc2VzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IikKICAgIHB1c2hieXRlcyAiQ29udHJhY3QgYWRkcmVzc2VzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IgogICAgcmV0c3ViCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [1166, 2009], "errorMessage": "Amount must be positive"}, {"pc": [1289], "errorMessage": "Conversion already executed"}, {"pc": [1280], "errorMessage": "Conversion not enabled"}, {"pc": [1264], "errorMessage": "Converter is paused"}, {"pc": [1798], "errorMessage": "Fee too high (max 10%)"}, {"pc": [2021], "errorMessage": "Insufficient PT balance"}, {"pc": [1333], "errorMessage": "Insufficient output amount"}, {"pc": [1036, 1654], "errorMessage": "Maturity must be in future"}, {"pc": [1305], "errorMessage": "No YT tokens to convert"}, {"pc": [424, 466, 490, 518, 542, 566, 590, 618, 642, 670, 690, 706, 722, 738, 761, 799, 827, 863], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [1901], "errorMessage": "Only admin can pause"}, {"pc": [1791], "errorMessage": "Only admin can set fee"}, {"pc": [1919], "errorMessage": "Only admin can unpause"}, {"pc": [2367], "errorMessage": "Only admin can update addresses"}, {"pc": [921], "errorMessage": "Only creator can initialize"}, {"pc": [1297], "errorMessage": "Threshold not reached"}, {"pc": [1030], "errorMessage": "Threshold price must be positive"}, {"pc": [1270], "errorMessage": "Transaction expired"}, {"pc": [910], "errorMessage": "can only call when creating"}, {"pc": [427, 469, 493, 521, 545, 569, 593, 621, 645, 673, 693, 709, 725, 741, 764, 802, 830, 866], "errorMessage": "can only call when not creating"}, {"pc": [1789, 1899, 1917, 2365], "errorMessage": "check self.admin exists"}, {"pc": [1277, 1461, 1512], "errorMessage": "check self.conversion_enabled exists for account"}, {"pc": [1287, 1473, 1536], "errorMessage": "check self.conversion_executed exists for account"}, {"pc": [1309, 1569, 1619, 1802], "errorMessage": "check self.conversion_fee exists"}, {"pc": [1317, 1627], "errorMessage": "check self.fee_denominator exists"}, {"pc": [1262, 1581], "errorMessage": "check self.is_paused exists"}, {"pc": [1345, 1562, 2016], "errorMessage": "check self.pt_balance exists for account"}, {"pc": [1296, 1498, 1520, 2166], "errorMessage": "check self.threshold_price exists for account"}, {"pc": [1366, 1575], "errorMessage": "check self.total_conversions exists"}, {"pc": [1528], "errorMessage": "check self.user_maturity exists for account"}, {"pc": [1172, 1303, 1486, 1554], "errorMessage": "check self.yt_balance exists for account"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class InitializeArgs:
    """Dataclass for initialize arguments"""
    oracle_address: bytes | str
    tokenization_address: bytes | str
    amm_address: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "initialize(byte[],byte[],byte[])string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ConfigureConversionArgs:
    """Dataclass for configure_conversion arguments"""
    enabled: int
    threshold_price: int
    maturity: int

    @property
    def abi_method_signature(self) -> str:
        return "configure_conversion(uint64,uint64,uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class DepositYtTokensArgs:
    """Dataclass for deposit_yt_tokens arguments"""
    amount: int

    @property
    def abi_method_signature(self) -> str:
        return "deposit_yt_tokens(uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ExecuteConversionArgs:
    """Dataclass for execute_conversion arguments"""
    user: bytes | str
    min_pt_amount: int
    deadline: int

    @property
    def abi_method_signature(self) -> str:
        return "execute_conversion(byte[],uint64,uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CanExecuteConversionArgs:
    """Dataclass for can_execute_conversion arguments"""
    user: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "can_execute_conversion(byte[])uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CalculateConversionOutputArgs:
    """Dataclass for calculate_conversion_output arguments"""
    yt_amount: int

    @property
    def abi_method_signature(self) -> str:
        return "calculate_conversion_output(uint64)(uint64,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class AddMaturityArgs:
    """Dataclass for add_maturity arguments"""
    maturity: int

    @property
    def abi_method_signature(self) -> str:
        return "add_maturity(uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetConversionFeeArgs:
    """Dataclass for set_conversion_fee arguments"""
    new_fee: int

    @property
    def abi_method_signature(self) -> str:
        return "set_conversion_fee(uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class WithdrawPtTokensArgs:
    """Dataclass for withdraw_pt_tokens arguments"""
    amount: int

    @property
    def abi_method_signature(self) -> str:
        return "withdraw_pt_tokens(uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetAiRecommendationArgs:
    """Dataclass for get_ai_recommendation arguments"""
    yt_amount: int
    current_price: int

    @property
    def abi_method_signature(self) -> str:
        return "get_ai_recommendation(uint64,uint64)(uint64,string)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpdateAddressesArgs:
    """Dataclass for update_addresses arguments"""
    oracle_address: bytes | str
    tokenization_address: bytes | str
    amm_address: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "update_addresses(byte[],byte[],byte[])string"


class YtAutoConverterParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def initialize(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | InitializeArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "initialize(byte[],byte[],byte[])string",
            "args": method_args,
        }))

    def configure_conversion(
        self,
        args: tuple[int, int, int] | ConfigureConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "configure_conversion(uint64,uint64,uint64)string",
            "args": method_args,
        }))

    def deposit_yt_tokens(
        self,
        args: tuple[int] | DepositYtTokensArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "deposit_yt_tokens(uint64)string",
            "args": method_args,
        }))

    def execute_conversion(
        self,
        args: tuple[bytes | str, int, int] | ExecuteConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "execute_conversion(byte[],uint64,uint64)string",
            "args": method_args,
        }))

    def can_execute_conversion(
        self,
        args: tuple[bytes | str] | CanExecuteConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "can_execute_conversion(byte[])uint64",
            "args": method_args,
        }))

    def get_user_config(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_user_config()(uint64,uint64,uint64,uint64)",
        }))

    def get_user_balances(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_user_balances()(uint64,uint64)",
        }))

    def get_conversion_info(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_conversion_info()(uint64,uint64,uint64)",
        }))

    def calculate_conversion_output(
        self,
        args: tuple[int] | CalculateConversionOutputArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "calculate_conversion_output(uint64)(uint64,uint64)",
            "args": method_args,
        }))

    def add_maturity(
        self,
        args: tuple[int] | AddMaturityArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "add_maturity(uint64)string",
            "args": method_args,
        }))

    def remove_maturity(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "remove_maturity()string",
        }))

    def set_conversion_fee(
        self,
        args: tuple[int] | SetConversionFeeArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_conversion_fee(uint64)string",
            "args": method_args,
        }))

    def pause_converter(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "pause_converter()string",
        }))

    def unpause_converter(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "unpause_converter()string",
        }))

    def emergency_disable_conversion(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "emergency_disable_conversion()string",
        }))

    def withdraw_pt_tokens(
        self,
        args: tuple[int] | WithdrawPtTokensArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_pt_tokens(uint64)string",
            "args": method_args,
        }))

    def get_ai_recommendation(
        self,
        args: tuple[int, int] | GetAiRecommendationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_ai_recommendation(uint64,uint64)(uint64,string)",
            "args": method_args,
        }))

    def update_addresses(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | UpdateAddressesArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "update_addresses(byte[],byte[],byte[])string",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class YtAutoConverterCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def initialize(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | InitializeArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "initialize(byte[],byte[],byte[])string",
            "args": method_args,
        }))

    def configure_conversion(
        self,
        args: tuple[int, int, int] | ConfigureConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "configure_conversion(uint64,uint64,uint64)string",
            "args": method_args,
        }))

    def deposit_yt_tokens(
        self,
        args: tuple[int] | DepositYtTokensArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "deposit_yt_tokens(uint64)string",
            "args": method_args,
        }))

    def execute_conversion(
        self,
        args: tuple[bytes | str, int, int] | ExecuteConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "execute_conversion(byte[],uint64,uint64)string",
            "args": method_args,
        }))

    def can_execute_conversion(
        self,
        args: tuple[bytes | str] | CanExecuteConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "can_execute_conversion(byte[])uint64",
            "args": method_args,
        }))

    def get_user_config(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_user_config()(uint64,uint64,uint64,uint64)",
        }))

    def get_user_balances(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_user_balances()(uint64,uint64)",
        }))

    def get_conversion_info(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_conversion_info()(uint64,uint64,uint64)",
        }))

    def calculate_conversion_output(
        self,
        args: tuple[int] | CalculateConversionOutputArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "calculate_conversion_output(uint64)(uint64,uint64)",
            "args": method_args,
        }))

    def add_maturity(
        self,
        args: tuple[int] | AddMaturityArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "add_maturity(uint64)string",
            "args": method_args,
        }))

    def remove_maturity(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "remove_maturity()string",
        }))

    def set_conversion_fee(
        self,
        args: tuple[int] | SetConversionFeeArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_conversion_fee(uint64)string",
            "args": method_args,
        }))

    def pause_converter(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "pause_converter()string",
        }))

    def unpause_converter(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "unpause_converter()string",
        }))

    def emergency_disable_conversion(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "emergency_disable_conversion()string",
        }))

    def withdraw_pt_tokens(
        self,
        args: tuple[int] | WithdrawPtTokensArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_pt_tokens(uint64)string",
            "args": method_args,
        }))

    def get_ai_recommendation(
        self,
        args: tuple[int, int] | GetAiRecommendationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_ai_recommendation(uint64,uint64)(uint64,string)",
            "args": method_args,
        }))

    def update_addresses(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | UpdateAddressesArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "update_addresses(byte[],byte[],byte[])string",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class YtAutoConverterSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def initialize(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | InitializeArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "initialize(byte[],byte[],byte[])string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def configure_conversion(
        self,
        args: tuple[int, int, int] | ConfigureConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "configure_conversion(uint64,uint64,uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def deposit_yt_tokens(
        self,
        args: tuple[int] | DepositYtTokensArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "deposit_yt_tokens(uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def execute_conversion(
        self,
        args: tuple[bytes | str, int, int] | ExecuteConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "execute_conversion(byte[],uint64,uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def can_execute_conversion(
        self,
        args: tuple[bytes | str] | CanExecuteConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "can_execute_conversion(byte[])uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def get_user_config(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[tuple[int, int, int, int]]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_user_config()(uint64,uint64,uint64,uint64)",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[tuple[int, int, int, int]], parsed_response)

    def get_user_balances(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[tuple[int, int]]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_user_balances()(uint64,uint64)",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[tuple[int, int]], parsed_response)

    def get_conversion_info(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[tuple[int, int, int]]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_conversion_info()(uint64,uint64,uint64)",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[tuple[int, int, int]], parsed_response)

    def calculate_conversion_output(
        self,
        args: tuple[int] | CalculateConversionOutputArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[tuple[int, int]]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "calculate_conversion_output(uint64)(uint64,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[tuple[int, int]], parsed_response)

    def add_maturity(
        self,
        args: tuple[int] | AddMaturityArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "add_maturity(uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def remove_maturity(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "remove_maturity()string",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def set_conversion_fee(
        self,
        args: tuple[int] | SetConversionFeeArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_conversion_fee(uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def pause_converter(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "pause_converter()string",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def unpause_converter(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "unpause_converter()string",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def emergency_disable_conversion(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "emergency_disable_conversion()string",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def withdraw_pt_tokens(
        self,
        args: tuple[int] | WithdrawPtTokensArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_pt_tokens(uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def get_ai_recommendation(
        self,
        args: tuple[int, int] | GetAiRecommendationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[tuple[int, str]]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_ai_recommendation(uint64,uint64)(uint64,string)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[tuple[int, str]], parsed_response)

    def update_addresses(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | UpdateAddressesArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "update_addresses(byte[],byte[],byte[])string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    admin: bytes
    oracle_address: bytes
    tokenization_address: bytes
    amm_address: bytes
    conversion_fee: int
    is_paused: int
    total_conversions: int
    max_slippage: int
    fee_denominator: int

class LocalStateValue(typing.TypedDict):
    """Shape of local_state state key values"""
    conversion_enabled: int
    threshold_price: int
    user_maturity: int
    conversion_executed: int
    yt_balance: int
    pt_balance: int

class YtAutoConverterState:
    """Methods to access state for the current YTAutoConverter app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    def local_state(
        self, address: str
    ) -> "_LocalState":
            """Methods to access local_state for the current app"""
            return _LocalState(self.app_client, address)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def admin(self) -> bytes:
        """Get the current value of the admin key in global_state state"""
        value = self.app_client.state.global_state.get_value("admin")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def oracle_address(self) -> bytes:
        """Get the current value of the oracle_address key in global_state state"""
        value = self.app_client.state.global_state.get_value("oracle_address")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def tokenization_address(self) -> bytes:
        """Get the current value of the tokenization_address key in global_state state"""
        value = self.app_client.state.global_state.get_value("tokenization_address")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def amm_address(self) -> bytes:
        """Get the current value of the amm_address key in global_state state"""
        value = self.app_client.state.global_state.get_value("amm_address")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def conversion_fee(self) -> int:
        """Get the current value of the conversion_fee key in global_state state"""
        value = self.app_client.state.global_state.get_value("conversion_fee")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def is_paused(self) -> int:
        """Get the current value of the is_paused key in global_state state"""
        value = self.app_client.state.global_state.get_value("is_paused")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def total_conversions(self) -> int:
        """Get the current value of the total_conversions key in global_state state"""
        value = self.app_client.state.global_state.get_value("total_conversions")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def max_slippage(self) -> int:
        """Get the current value of the max_slippage key in global_state state"""
        value = self.app_client.state.global_state.get_value("max_slippage")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def fee_denominator(self) -> int:
        """Get the current value of the fee_denominator key in global_state state"""
        value = self.app_client.state.global_state.get_value("fee_denominator")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class _LocalState:
    def __init__(self, app_client: algokit_utils.AppClient, address: str):
        self.app_client = app_client
        self.address = address
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> LocalStateValue:
        """Get all current keyed values from local_state state"""
        result = self.app_client.state.local_state(self.address).get_all()
        if not result:
            return typing.cast(LocalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.local_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(LocalStateValue, converted)

    @property
    def conversion_enabled(self) -> int:
        """Get the current value of the conversion_enabled key in local_state state"""
        value = self.app_client.state.local_state(self.address).get_value("conversion_enabled")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def threshold_price(self) -> int:
        """Get the current value of the threshold_price key in local_state state"""
        value = self.app_client.state.local_state(self.address).get_value("threshold_price")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def user_maturity(self) -> int:
        """Get the current value of the user_maturity key in local_state state"""
        value = self.app_client.state.local_state(self.address).get_value("user_maturity")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def conversion_executed(self) -> int:
        """Get the current value of the conversion_executed key in local_state state"""
        value = self.app_client.state.local_state(self.address).get_value("conversion_executed")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def yt_balance(self) -> int:
        """Get the current value of the yt_balance key in local_state state"""
        value = self.app_client.state.local_state(self.address).get_value("yt_balance")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def pt_balance(self) -> int:
        """Get the current value of the pt_balance key in local_state state"""
        value = self.app_client.state.local_state(self.address).get_value("pt_balance")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class YtAutoConverterClient:
    """Client for interacting with YTAutoConverter smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = YtAutoConverterParams(self.app_client)
        self.create_transaction = YtAutoConverterCreateTransactionParams(self.app_client)
        self.send = YtAutoConverterSend(self.app_client)
        self.state = YtAutoConverterState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "YtAutoConverterClient":
        return YtAutoConverterClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "YtAutoConverterClient":
        return YtAutoConverterClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "YtAutoConverterClient":
        return YtAutoConverterClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "YtAutoConverterComposer":
        return YtAutoConverterComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["initialize(byte[],byte[],byte[])string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["configure_conversion(uint64,uint64,uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["deposit_yt_tokens(uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["execute_conversion(byte[],uint64,uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["can_execute_conversion(byte[])uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_user_config()(uint64,uint64,uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> tuple[int, int, int, int] | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_user_balances()(uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> tuple[int, int] | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_conversion_info()(uint64,uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> tuple[int, int, int] | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["calculate_conversion_output(uint64)(uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> tuple[int, int] | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["add_maturity(uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["remove_maturity()string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["set_conversion_fee(uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["pause_converter()string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["unpause_converter()string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["emergency_disable_conversion()string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["withdraw_pt_tokens(uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_ai_recommendation(uint64,uint64)(uint64,string)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> tuple[int, str] | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["update_addresses(byte[],byte[],byte[])string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | int | str | tuple[int, int, int, int] | tuple[int, int, int] | tuple[int, int] | tuple[int, str]:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class YtAutoConverterBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating YtAutoConverter contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class YtAutoConverterFactory(algokit_utils.TypedAppFactoryProtocol[YtAutoConverterBareCallCreateParams, None, None]):
    """Factory for deploying and managing YtAutoConverterClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = YtAutoConverterFactoryParams(self.app_factory)
        self.create_transaction = YtAutoConverterFactoryCreateTransaction(self.app_factory)
        self.send = YtAutoConverterFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: YtAutoConverterBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[YtAutoConverterClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return YtAutoConverterClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> YtAutoConverterClient:
        """Get an app client by creator address and name"""
        return YtAutoConverterClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> YtAutoConverterClient:
        """Get an app client by app ID"""
        return YtAutoConverterClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class YtAutoConverterFactoryParams:
    """Parameters for creating transactions for YtAutoConverter contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = YtAutoConverterFactoryCreateParams(app_factory)
        self.update = YtAutoConverterFactoryUpdateParams(app_factory)
        self.delete = YtAutoConverterFactoryDeleteParams(app_factory)

class YtAutoConverterFactoryCreateParams:
    """Parameters for 'create' operations of YtAutoConverter contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def initialize(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | InitializeArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the initialize(byte[],byte[],byte[])string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "initialize(byte[],byte[],byte[])string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def configure_conversion(
        self,
        args: tuple[int, int, int] | ConfigureConversionArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the configure_conversion(uint64,uint64,uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "configure_conversion(uint64,uint64,uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def deposit_yt_tokens(
        self,
        args: tuple[int] | DepositYtTokensArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the deposit_yt_tokens(uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "deposit_yt_tokens(uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def execute_conversion(
        self,
        args: tuple[bytes | str, int, int] | ExecuteConversionArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the execute_conversion(byte[],uint64,uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "execute_conversion(byte[],uint64,uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def can_execute_conversion(
        self,
        args: tuple[bytes | str] | CanExecuteConversionArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the can_execute_conversion(byte[])uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "can_execute_conversion(byte[])uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_user_config(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_user_config()(uint64,uint64,uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_user_config()(uint64,uint64,uint64,uint64)",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def get_user_balances(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_user_balances()(uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_user_balances()(uint64,uint64)",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def get_conversion_info(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_conversion_info()(uint64,uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_conversion_info()(uint64,uint64,uint64)",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def calculate_conversion_output(
        self,
        args: tuple[int] | CalculateConversionOutputArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the calculate_conversion_output(uint64)(uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "calculate_conversion_output(uint64)(uint64,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def add_maturity(
        self,
        args: tuple[int] | AddMaturityArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the add_maturity(uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "add_maturity(uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def remove_maturity(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the remove_maturity()string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "remove_maturity()string",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def set_conversion_fee(
        self,
        args: tuple[int] | SetConversionFeeArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the set_conversion_fee(uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "set_conversion_fee(uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def pause_converter(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the pause_converter()string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "pause_converter()string",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def unpause_converter(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the unpause_converter()string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "unpause_converter()string",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def emergency_disable_conversion(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the emergency_disable_conversion()string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "emergency_disable_conversion()string",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def withdraw_pt_tokens(
        self,
        args: tuple[int] | WithdrawPtTokensArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the withdraw_pt_tokens(uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "withdraw_pt_tokens(uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_ai_recommendation(
        self,
        args: tuple[int, int] | GetAiRecommendationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_ai_recommendation(uint64,uint64)(uint64,string) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_ai_recommendation(uint64,uint64)(uint64,string)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def update_addresses(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | UpdateAddressesArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the update_addresses(byte[],byte[],byte[])string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "update_addresses(byte[],byte[],byte[])string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class YtAutoConverterFactoryUpdateParams:
    """Parameters for 'update' operations of YtAutoConverter contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class YtAutoConverterFactoryDeleteParams:
    """Parameters for 'delete' operations of YtAutoConverter contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class YtAutoConverterFactoryCreateTransaction:
    """Create transactions for YtAutoConverter contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = YtAutoConverterFactoryCreateTransactionCreate(app_factory)


class YtAutoConverterFactoryCreateTransactionCreate:
    """Create new instances of YtAutoConverter contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class YtAutoConverterFactorySend:
    """Send calls to YtAutoConverter contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = YtAutoConverterFactorySendCreate(app_factory)


class YtAutoConverterFactorySendCreate:
    """Send create calls to YtAutoConverter contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[YtAutoConverterClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return YtAutoConverterClient(result[0]), result[1]


class YtAutoConverterComposer:
    """Composer for creating transaction groups for YtAutoConverter contract calls"""

    def __init__(self, client: "YtAutoConverterClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def initialize(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | InitializeArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.initialize(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "initialize(byte[],byte[],byte[])string", v
            )
        )
        return self

    def configure_conversion(
        self,
        args: tuple[int, int, int] | ConfigureConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.configure_conversion(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "configure_conversion(uint64,uint64,uint64)string", v
            )
        )
        return self

    def deposit_yt_tokens(
        self,
        args: tuple[int] | DepositYtTokensArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.deposit_yt_tokens(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "deposit_yt_tokens(uint64)string", v
            )
        )
        return self

    def execute_conversion(
        self,
        args: tuple[bytes | str, int, int] | ExecuteConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.execute_conversion(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "execute_conversion(byte[],uint64,uint64)string", v
            )
        )
        return self

    def can_execute_conversion(
        self,
        args: tuple[bytes | str] | CanExecuteConversionArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.can_execute_conversion(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "can_execute_conversion(byte[])uint64", v
            )
        )
        return self

    def get_user_config(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_user_config(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_user_config()(uint64,uint64,uint64,uint64)", v
            )
        )
        return self

    def get_user_balances(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_user_balances(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_user_balances()(uint64,uint64)", v
            )
        )
        return self

    def get_conversion_info(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_conversion_info(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_conversion_info()(uint64,uint64,uint64)", v
            )
        )
        return self

    def calculate_conversion_output(
        self,
        args: tuple[int] | CalculateConversionOutputArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.calculate_conversion_output(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "calculate_conversion_output(uint64)(uint64,uint64)", v
            )
        )
        return self

    def add_maturity(
        self,
        args: tuple[int] | AddMaturityArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.add_maturity(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "add_maturity(uint64)string", v
            )
        )
        return self

    def remove_maturity(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.remove_maturity(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "remove_maturity()string", v
            )
        )
        return self

    def set_conversion_fee(
        self,
        args: tuple[int] | SetConversionFeeArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.set_conversion_fee(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "set_conversion_fee(uint64)string", v
            )
        )
        return self

    def pause_converter(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.pause_converter(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "pause_converter()string", v
            )
        )
        return self

    def unpause_converter(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.unpause_converter(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "unpause_converter()string", v
            )
        )
        return self

    def emergency_disable_conversion(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.emergency_disable_conversion(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "emergency_disable_conversion()string", v
            )
        )
        return self

    def withdraw_pt_tokens(
        self,
        args: tuple[int] | WithdrawPtTokensArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.withdraw_pt_tokens(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "withdraw_pt_tokens(uint64)string", v
            )
        )
        return self

    def get_ai_recommendation(
        self,
        args: tuple[int, int] | GetAiRecommendationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_ai_recommendation(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_ai_recommendation(uint64,uint64)(uint64,string)", v
            )
        )
        return self

    def update_addresses(
        self,
        args: tuple[bytes | str, bytes | str, bytes | str] | UpdateAddressesArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_app_call_method_call(
            self.client.params.update_addresses(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "update_addresses(byte[],byte[],byte[])string", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "YtAutoConverterComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "YtAutoConverterComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
