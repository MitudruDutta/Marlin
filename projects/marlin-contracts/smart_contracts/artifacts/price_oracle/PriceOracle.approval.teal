#pragma version 10
#pragma typetrack false

// smart_contracts.price_oracle.contract.PriceOracle.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 10000
    bytecblock 0x151f7c75 "admin" "token_price" "price_timestamp" "threshold_price" "threshold_active" "circuit_breaker" "is_paused" "updater_count" "staleness_threshold" "price_confidence" "is_updater" "max_price_deviation" "min_update_interval" 0x4369726375697420627265616b657220616374697661746564 0x4369726375697420627265616b6572207265736574 0x4f7261636c6520706175736564 0x4f7261636c6520756e706175736564
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/price_oracle/contract.py:41-42
    // # Price constants
    // self.max_price_deviation = UInt64(1000)  # 10% in basis points
    bytec 12 // "max_price_deviation"
    pushint 1000 // 1000
    app_global_put
    // smart_contracts/price_oracle/contract.py:43
    // self.min_update_interval = UInt64(300)   # 5 minutes
    bytec 13 // "min_update_interval"
    pushint 300 // 300
    app_global_put
    // smart_contracts/price_oracle/contract.py:44
    // self.staleness_threshold = UInt64(3600)  # 1 hour
    bytec 9 // "staleness_threshold"
    pushint 3600 // 3600
    app_global_put

main_after_if_else@2:
    // smart_contracts/price_oracle/contract.py:31
    // class PriceOracle(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@21
    pushbytess 0x897ad1a7 0xdd99d59a 0x12c1126f 0x7dc6483c 0x5d3878d0 0x144fe4f9 0x6a76def2 0xfa8cff2d 0xfd9c53e0 0x45a05b30 0x7a451eaa 0x6fe40fe1 0x8dac55d3 0x74b65876 0x25376950 0x4cf3645a // method "initialize()string", method "add_price_updater(byte[])string", method "update_price(uint64,uint64)string", method "set_threshold(uint64)string", method "get_price()uint64", method "get_price_info()(uint64,uint64,uint64)", method "is_price_stale()uint64", method "threshold_reached()uint64", method "get_threshold_info()(uint64,uint64)", method "activate_circuit_breaker()string", method "reset_circuit_breaker()string", method "pause_oracle()string", method "unpause_oracle()string", method "get_oracle_status()(uint64,uint64,uint64)", method "remove_threshold()string", method "get_price_history_summary()(uint64,uint64,uint64)"
    txna ApplicationArgs 0
    match main_initialize_route@5 main_add_price_updater_route@6 main_update_price_route@7 main_set_threshold_route@8 main_get_price_route@9 main_get_price_info_route@10 main_is_price_stale_route@11 main_threshold_reached_route@12 main_get_threshold_info_route@13 main_activate_circuit_breaker_route@14 main_reset_circuit_breaker_route@15 main_pause_oracle_route@16 main_unpause_oracle_route@17 main_get_oracle_status_route@18 main_remove_threshold_route@19 main_get_price_history_summary_route@20

main_after_if_else@23:
    // smart_contracts/price_oracle/contract.py:31
    // class PriceOracle(ARC4Contract):
    intc_0 // 0
    return

main_get_price_history_summary_route@20:
    // smart_contracts/price_oracle/contract.py:297
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_price_history_summary
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_remove_threshold_route@19:
    // smart_contracts/price_oracle/contract.py:265
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub remove_threshold
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_oracle_status_route@18:
    // smart_contracts/price_oracle/contract.py:256
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_oracle_status
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_unpause_oracle_route@17:
    // smart_contracts/price_oracle/contract.py:247
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub unpause_oracle
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_pause_oracle_route@16:
    // smart_contracts/price_oracle/contract.py:238
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub pause_oracle
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_reset_circuit_breaker_route@15:
    // smart_contracts/price_oracle/contract.py:228
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub reset_circuit_breaker
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_activate_circuit_breaker_route@14:
    // smart_contracts/price_oracle/contract.py:218
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub activate_circuit_breaker
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_threshold_info_route@13:
    // smart_contracts/price_oracle/contract.py:210
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_threshold_info
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_threshold_reached_route@12:
    // smart_contracts/price_oracle/contract.py:189
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub threshold_reached
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_is_price_stale_route@11:
    // smart_contracts/price_oracle/contract.py:176
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub is_price_stale
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_price_info_route@10:
    // smart_contracts/price_oracle/contract.py:167
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_price_info
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_price_route@9:
    // smart_contracts/price_oracle/contract.py:154
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_price
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_set_threshold_route@8:
    // smart_contracts/price_oracle/contract.py:139
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/price_oracle/contract.py:31
    // class PriceOracle(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/price_oracle/contract.py:139
    // @arc4.abimethod
    callsub set_threshold
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_update_price_route@7:
    // smart_contracts/price_oracle/contract.py:94
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/price_oracle/contract.py:31
    // class PriceOracle(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/price_oracle/contract.py:94
    // @arc4.abimethod
    callsub update_price
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_add_price_updater_route@6:
    // smart_contracts/price_oracle/contract.py:82
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/price_oracle/contract.py:31
    // class PriceOracle(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/price_oracle/contract.py:82
    // @arc4.abimethod
    callsub add_price_updater
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initialize_route@5:
    // smart_contracts/price_oracle/contract.py:60
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub initialize
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@21:
    // smart_contracts/price_oracle/contract.py:31
    // class PriceOracle(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@23
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.price_oracle.contract.PriceOracle.initialize() -> bytes:
initialize:
    // smart_contracts/price_oracle/contract.py:63
    // assert Txn.sender == Global.creator_address, "Only creator can initialize"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // smart_contracts/price_oracle/contract.py:65
    // self.admin.value = Txn.sender.bytes
    bytec_1 // "admin"
    txn Sender
    app_global_put
    // smart_contracts/price_oracle/contract.py:66
    // self.circuit_breaker_active.value = UInt64(0)
    bytec 6 // "circuit_breaker"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:67
    // self.is_paused.value = UInt64(0)
    bytec 7 // "is_paused"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:68
    // self.updater_count.value = UInt64(0)
    bytec 8 // "updater_count"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:69
    // self.token_price.value = UInt64(0)
    bytec_2 // "token_price"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:70
    // self.price_timestamp.value = UInt64(0)
    bytec_3 // "price_timestamp"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:71
    // self.price_confidence.value = UInt64(0)
    bytec 10 // "price_confidence"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:72
    // self.threshold_price.value = UInt64(0)
    bytec 4 // "threshold_price"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:73
    // self.threshold_active.value = UInt64(0)
    bytec 5 // "threshold_active"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:75-76
    // # Add admin as first price updater
    // self.is_updater[Txn.sender] = UInt64(1)
    txn Sender
    bytec 11 // "is_updater"
    intc_1 // 1
    app_local_put
    // smart_contracts/price_oracle/contract.py:77
    // self.updater_count.value = UInt64(1)
    bytec 8 // "updater_count"
    intc_1 // 1
    app_global_put
    // smart_contracts/price_oracle/contract.py:79
    // log(b"PriceOracle initialized")
    pushbytes 0x50726963654f7261636c6520696e697469616c697a6564
    log
    // smart_contracts/price_oracle/contract.py:80
    // return String("Price oracle initialized successfully")
    pushbytes "Price oracle initialized successfully"
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.add_price_updater(updater: bytes) -> bytes:
add_price_updater:
    // smart_contracts/price_oracle/contract.py:82-83
    // @arc4.abimethod
    // def add_price_updater(self, updater: Bytes) -> String:
    proto 1 1
    // smart_contracts/price_oracle/contract.py:85
    // assert Txn.sender.bytes == self.admin.value, "Only admin can add updaters"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can add updaters
    // smart_contracts/price_oracle/contract.py:87-89
    // # In production, would need proper address validation
    // # For simplicity, just incrementing count
    // self.updater_count.value = self.updater_count.value + UInt64(1)
    intc_0 // 0
    bytec 8 // "updater_count"
    app_global_get_ex
    assert // check self.updater_count exists
    intc_1 // 1
    +
    bytec 8 // "updater_count"
    swap
    app_global_put
    // smart_contracts/price_oracle/contract.py:91
    // log(b"Price updater added")
    pushbytes 0x50726963652075706461746572206164646564
    log
    // smart_contracts/price_oracle/contract.py:92
    // return String("Price updater added successfully")
    pushbytes "Price updater added successfully"
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.update_price(new_price: uint64, confidence: uint64) -> bytes:
update_price:
    // smart_contracts/price_oracle/contract.py:94-99
    // @arc4.abimethod
    // def update_price(
    //     self,
    //     new_price: UInt64,
    //     confidence: UInt64,
    // ) -> String:
    proto 2 1
    pushbytes ""
    dupn 2
    // smart_contracts/price_oracle/contract.py:101
    // assert self.is_paused.value == UInt64(0), "Oracle is paused"
    intc_0 // 0
    bytec 7 // "is_paused"
    app_global_get_ex
    assert // check self.is_paused exists
    !
    assert // Oracle is paused
    // smart_contracts/price_oracle/contract.py:102
    // assert self.circuit_breaker_active.value == UInt64(0), "Circuit breaker active"
    intc_0 // 0
    bytec 6 // "circuit_breaker"
    app_global_get_ex
    assert // check self.circuit_breaker_active exists
    !
    assert // Circuit breaker active
    // smart_contracts/price_oracle/contract.py:103
    // assert new_price > UInt64(0), "Price must be positive"
    frame_dig -2
    assert // Price must be positive
    // smart_contracts/price_oracle/contract.py:104
    // assert confidence <= UInt64(10000), "Confidence cannot exceed 100%"
    frame_dig -1
    intc_2 // 10000
    <=
    assert // Confidence cannot exceed 100%
    // smart_contracts/price_oracle/contract.py:109
    // Txn.sender.bytes == self.admin.value or self.is_updater[Txn.sender] == UInt64(1)
    txn Sender
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    bnz update_price_bool_true@2
    txn Sender
    intc_0 // 0
    bytec 11 // "is_updater"
    app_local_get_ex
    assert // check self.is_updater exists for account
    intc_1 // 1
    ==
    bz update_price_bool_false@3

update_price_bool_true@2:
    intc_1 // 1

update_price_bool_merge@4:
    // smart_contracts/price_oracle/contract.py:106-110
    // # Check if sender is authorized updater (simplified)
    // # In production, would check against stored updater list
    // assert (
    //     Txn.sender.bytes == self.admin.value or self.is_updater[Txn.sender] == UInt64(1)
    // ), "Not authorized to update price"
    assert // Not authorized to update price
    // smart_contracts/price_oracle/contract.py:112
    // current_price = self.token_price.value
    intc_0 // 0
    bytec_2 // "token_price"
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.token_price exists
    // smart_contracts/price_oracle/contract.py:113
    // current_timestamp = self.price_timestamp.value
    intc_0 // 0
    bytec_3 // "price_timestamp"
    app_global_get_ex
    swap
    frame_bury 1
    assert // check self.price_timestamp exists
    // smart_contracts/price_oracle/contract.py:115-116
    // # Check minimum update interval for existing prices
    // if current_price > UInt64(0):
    bz update_price_after_if_else@6
    // smart_contracts/price_oracle/contract.py:118
    // Global.latest_timestamp >= current_timestamp + self.min_update_interval
    global LatestTimestamp
    intc_0 // 0
    bytec 13 // "min_update_interval"
    app_global_get_ex
    assert // check self.min_update_interval exists
    frame_dig 1
    +
    >=
    // smart_contracts/price_oracle/contract.py:117-119
    // assert (
    //     Global.latest_timestamp >= current_timestamp + self.min_update_interval
    // ), "Update too frequent"
    assert // Update too frequent
    // smart_contracts/price_oracle/contract.py:279
    // if old_price == UInt64(0):
    frame_dig 0
    bnz update_price_after_if_else@15
    // smart_contracts/price_oracle/contract.py:280
    // return UInt64(0)
    intc_0 // 0

update_price_after_inlined_smart_contracts.price_oracle.contract.PriceOracle._calculate_deviation@19:
    // smart_contracts/price_oracle/contract.py:123
    // assert deviation <= self.max_price_deviation, "Price deviation too large"
    intc_0 // 0
    bytec 12 // "max_price_deviation"
    app_global_get_ex
    assert // check self.max_price_deviation exists
    <=
    assert // Price deviation too large

update_price_after_if_else@6:
    // smart_contracts/price_oracle/contract.py:127-128
    // # Update price data
    // self.token_price.value = new_price
    bytec_2 // "token_price"
    frame_dig -2
    app_global_put
    // smart_contracts/price_oracle/contract.py:129
    // self.price_timestamp.value = Global.latest_timestamp
    bytec_3 // "price_timestamp"
    global LatestTimestamp
    app_global_put
    // smart_contracts/price_oracle/contract.py:130
    // self.price_confidence.value = confidence
    bytec 10 // "price_confidence"
    frame_dig -1
    app_global_put
    // smart_contracts/price_oracle/contract.py:131
    // self.price_updater.value = Txn.sender.bytes
    pushbytes "price_updater"
    txn Sender
    app_global_put
    // smart_contracts/price_oracle/contract.py:292
    // if self.threshold_active.value == UInt64(1):
    intc_0 // 0
    bytec 5 // "threshold_active"
    app_global_get_ex
    assert // check self.threshold_active exists
    intc_1 // 1
    ==
    bz update_price_after_if_else@11
    // smart_contracts/price_oracle/contract.py:293
    // threshold = self.threshold_price.value
    intc_0 // 0
    bytec 4 // "threshold_price"
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 2
    assert // check self.threshold_price exists
    // smart_contracts/price_oracle/contract.py:294
    // if current_price >= threshold:
    frame_dig -2
    <=
    bz update_price_after_if_else@11
    // smart_contracts/price_oracle/contract.py:295
    // log(b"Threshold reached - Price: " + op.itob(current_price) + b" Threshold: " + op.itob(threshold))
    frame_dig -2
    itob
    pushbytes 0x5468726573686f6c642072656163686564202d2050726963653a20
    swap
    concat
    pushbytes 0x205468726573686f6c643a20
    concat
    frame_dig 2
    itob
    concat
    log

update_price_after_if_else@11:
    // smart_contracts/price_oracle/contract.py:136
    // log(b"Price updated - Old: " + op.itob(old_price) + b" New: " + op.itob(new_price))
    frame_dig 0
    itob
    pushbytes 0x50726963652075706461746564202d204f6c643a20
    swap
    concat
    pushbytes 0x204e65773a20
    concat
    frame_dig -2
    itob
    concat
    log
    // smart_contracts/price_oracle/contract.py:137
    // return String("Price updated successfully")
    pushbytes "Price updated successfully"
    frame_bury 0
    retsub

update_price_after_if_else@15:
    // smart_contracts/price_oracle/contract.py:282
    // if old_price > new_price:
    frame_dig 0
    frame_dig -2
    >
    bz update_price_else_body@17
    // smart_contracts/price_oracle/contract.py:283
    // deviation = ((old_price - new_price) * UInt64(10000)) // old_price
    frame_dig 0
    dup
    frame_dig -2
    -
    intc_2 // 10000
    *
    swap
    /
    b update_price_after_inlined_smart_contracts.price_oracle.contract.PriceOracle._calculate_deviation@19

update_price_else_body@17:
    // smart_contracts/price_oracle/contract.py:285
    // deviation = ((new_price - old_price) * UInt64(10000)) // old_price
    frame_dig -2
    frame_dig 0
    dup
    cover 2
    -
    intc_2 // 10000
    *
    swap
    /
    b update_price_after_inlined_smart_contracts.price_oracle.contract.PriceOracle._calculate_deviation@19

update_price_bool_false@3:
    intc_0 // 0
    b update_price_bool_merge@4


// smart_contracts.price_oracle.contract.PriceOracle.set_threshold(threshold: uint64) -> bytes:
set_threshold:
    // smart_contracts/price_oracle/contract.py:139-140
    // @arc4.abimethod
    // def set_threshold(self, threshold: UInt64) -> String:
    proto 1 1
    // smart_contracts/price_oracle/contract.py:142
    // assert threshold > UInt64(0), "Threshold must be positive"
    frame_dig -1
    assert // Threshold must be positive
    // smart_contracts/price_oracle/contract.py:144
    // Txn.sender.bytes == self.admin.value or self.is_updater[Txn.sender] == UInt64(1)
    txn Sender
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    bnz set_threshold_bool_true@2
    txn Sender
    intc_0 // 0
    bytec 11 // "is_updater"
    app_local_get_ex
    assert // check self.is_updater exists for account
    intc_1 // 1
    ==
    bz set_threshold_bool_false@3

set_threshold_bool_true@2:
    intc_1 // 1

set_threshold_bool_merge@4:
    // smart_contracts/price_oracle/contract.py:143-145
    // assert (
    //     Txn.sender.bytes == self.admin.value or self.is_updater[Txn.sender] == UInt64(1)
    // ), "Not authorized to set threshold"
    assert // Not authorized to set threshold
    // smart_contracts/price_oracle/contract.py:147
    // self.threshold_price.value = threshold
    bytec 4 // "threshold_price"
    frame_dig -1
    app_global_put
    // smart_contracts/price_oracle/contract.py:148
    // self.threshold_active.value = UInt64(1)
    bytec 5 // "threshold_active"
    intc_1 // 1
    app_global_put
    // smart_contracts/price_oracle/contract.py:149
    // self.threshold_setter.value = Txn.sender.bytes
    pushbytes "threshold_setter"
    txn Sender
    app_global_put
    // smart_contracts/price_oracle/contract.py:151
    // log(b"Threshold set - Value: " + op.itob(threshold))
    frame_dig -1
    itob
    pushbytes 0x5468726573686f6c6420736574202d2056616c75653a20
    swap
    concat
    log
    // smart_contracts/price_oracle/contract.py:152
    // return String("Threshold set successfully")
    pushbytes "Threshold set successfully"
    retsub

set_threshold_bool_false@3:
    intc_0 // 0
    b set_threshold_bool_merge@4


// smart_contracts.price_oracle.contract.PriceOracle.get_price() -> uint64:
get_price:
    // smart_contracts/price_oracle/contract.py:157
    // current_price = self.token_price.value
    intc_0 // 0
    bytec_2 // "token_price"
    app_global_get_ex
    assert // check self.token_price exists
    // smart_contracts/price_oracle/contract.py:158
    // price_timestamp = self.price_timestamp.value
    intc_0 // 0
    bytec_3 // "price_timestamp"
    app_global_get_ex
    assert // check self.price_timestamp exists
    // smart_contracts/price_oracle/contract.py:160
    // assert current_price > UInt64(0), "No price available"
    dig 1
    assert // No price available
    // smart_contracts/price_oracle/contract.py:162
    // Global.latest_timestamp <= price_timestamp + self.staleness_threshold
    global LatestTimestamp
    intc_0 // 0
    bytec 9 // "staleness_threshold"
    app_global_get_ex
    assert // check self.staleness_threshold exists
    uncover 2
    +
    <=
    // smart_contracts/price_oracle/contract.py:161-163
    // assert (
    //     Global.latest_timestamp <= price_timestamp + self.staleness_threshold
    // ), "Price is stale"
    assert // Price is stale
    // smart_contracts/price_oracle/contract.py:165
    // return current_price
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.get_price_info() -> bytes:
get_price_info:
    // smart_contracts/price_oracle/contract.py:171
    // arc4.UInt64(self.token_price.value),
    intc_0 // 0
    bytec_2 // "token_price"
    app_global_get_ex
    assert // check self.token_price exists
    itob
    // smart_contracts/price_oracle/contract.py:172
    // arc4.UInt64(self.price_timestamp.value),
    intc_0 // 0
    bytec_3 // "price_timestamp"
    app_global_get_ex
    assert // check self.price_timestamp exists
    itob
    // smart_contracts/price_oracle/contract.py:173
    // arc4.UInt64(self.price_confidence.value)
    intc_0 // 0
    bytec 10 // "price_confidence"
    app_global_get_ex
    assert // check self.price_confidence exists
    itob
    // smart_contracts/price_oracle/contract.py:170-174
    // return arc4.Tuple((
    //     arc4.UInt64(self.token_price.value),
    //     arc4.UInt64(self.price_timestamp.value),
    //     arc4.UInt64(self.price_confidence.value)
    // ))
    cover 2
    concat
    swap
    concat
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.is_price_stale() -> uint64:
is_price_stale:
    // smart_contracts/price_oracle/contract.py:176-177
    // @arc4.abimethod(readonly=True)
    // def is_price_stale(self) -> UInt64:
    proto 0 1
    // smart_contracts/price_oracle/contract.py:179
    // price_timestamp = self.price_timestamp.value
    intc_0 // 0
    bytec_3 // "price_timestamp"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.price_timestamp exists
    // smart_contracts/price_oracle/contract.py:181
    // if price_timestamp == UInt64(0):
    bnz is_price_stale_after_if_else@2
    // smart_contracts/price_oracle/contract.py:182
    // return UInt64(1)  # No price set, considered stale
    intc_1 // 1
    swap
    retsub

is_price_stale_after_if_else@2:
    // smart_contracts/price_oracle/contract.py:184
    // if Global.latest_timestamp > price_timestamp + self.staleness_threshold:
    global LatestTimestamp
    intc_0 // 0
    bytec 9 // "staleness_threshold"
    app_global_get_ex
    assert // check self.staleness_threshold exists
    frame_dig 0
    +
    >
    bz is_price_stale_else_body@4
    // smart_contracts/price_oracle/contract.py:185
    // return UInt64(1)  # Stale
    intc_1 // 1
    swap
    retsub

is_price_stale_else_body@4:
    // smart_contracts/price_oracle/contract.py:187
    // return UInt64(0)  # Fresh
    intc_0 // 0
    swap
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.threshold_reached() -> uint64:
threshold_reached:
    // smart_contracts/price_oracle/contract.py:189-190
    // @arc4.abimethod(readonly=True)
    // def threshold_reached(self) -> UInt64:
    proto 0 1
    pushbytes ""
    dup
    // smart_contracts/price_oracle/contract.py:192
    // if self.threshold_active.value == UInt64(0):
    intc_0 // 0
    bytec 5 // "threshold_active"
    app_global_get_ex
    assert // check self.threshold_active exists
    bnz threshold_reached_after_if_else@2
    // smart_contracts/price_oracle/contract.py:193
    // return UInt64(0)  # Threshold not active
    intc_0 // 0
    frame_bury 0
    retsub

threshold_reached_after_if_else@2:
    // smart_contracts/price_oracle/contract.py:195
    // current_price = self.token_price.value
    intc_0 // 0
    bytec_2 // "token_price"
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.token_price exists
    // smart_contracts/price_oracle/contract.py:196
    // threshold = self.threshold_price.value
    intc_0 // 0
    bytec 4 // "threshold_price"
    app_global_get_ex
    swap
    frame_bury 1
    assert // check self.threshold_price exists
    // smart_contracts/price_oracle/contract.py:198
    // if current_price == UInt64(0):
    bnz threshold_reached_after_if_else@4
    // smart_contracts/price_oracle/contract.py:199
    // return UInt64(0)  # No price available
    intc_0 // 0
    frame_bury 0
    retsub

threshold_reached_after_if_else@4:
    // smart_contracts/price_oracle/contract.py:201-202
    // # Check if price is fresh
    // if self.is_price_stale() == UInt64(1):
    callsub is_price_stale
    intc_1 // 1
    ==
    bz threshold_reached_after_if_else@6
    // smart_contracts/price_oracle/contract.py:203
    // return UInt64(0)  # Price is stale
    intc_0 // 0
    frame_bury 0
    retsub

threshold_reached_after_if_else@6:
    // smart_contracts/price_oracle/contract.py:205
    // if current_price >= threshold:
    frame_dig 0
    frame_dig 1
    >=
    bz threshold_reached_else_body@8
    // smart_contracts/price_oracle/contract.py:206
    // return UInt64(1)  # Threshold reached
    intc_1 // 1
    frame_bury 0
    retsub

threshold_reached_else_body@8:
    // smart_contracts/price_oracle/contract.py:208
    // return UInt64(0)  # Threshold not reached
    intc_0 // 0
    frame_bury 0
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.get_threshold_info() -> bytes:
get_threshold_info:
    // smart_contracts/price_oracle/contract.py:214
    // arc4.UInt64(self.threshold_price.value),
    intc_0 // 0
    bytec 4 // "threshold_price"
    app_global_get_ex
    assert // check self.threshold_price exists
    itob
    // smart_contracts/price_oracle/contract.py:215
    // arc4.UInt64(self.threshold_active.value)
    intc_0 // 0
    bytec 5 // "threshold_active"
    app_global_get_ex
    assert // check self.threshold_active exists
    itob
    // smart_contracts/price_oracle/contract.py:213-216
    // return arc4.Tuple((
    //     arc4.UInt64(self.threshold_price.value),
    //     arc4.UInt64(self.threshold_active.value)
    // ))
    concat
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.activate_circuit_breaker() -> bytes:
activate_circuit_breaker:
    // smart_contracts/price_oracle/contract.py:221
    // assert Txn.sender.bytes == self.admin.value, "Only admin can activate circuit breaker"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can activate circuit breaker
    // smart_contracts/price_oracle/contract.py:223
    // self.circuit_breaker_active.value = UInt64(1)
    bytec 6 // "circuit_breaker"
    intc_1 // 1
    app_global_put
    // smart_contracts/price_oracle/contract.py:225
    // log(b"Circuit breaker activated")
    bytec 14 // 0x4369726375697420627265616b657220616374697661746564
    log
    // smart_contracts/price_oracle/contract.py:226
    // return String("Circuit breaker activated")
    bytec 14 // "Circuit breaker activated"
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.reset_circuit_breaker() -> bytes:
reset_circuit_breaker:
    // smart_contracts/price_oracle/contract.py:231
    // assert Txn.sender.bytes == self.admin.value, "Only admin can reset circuit breaker"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can reset circuit breaker
    // smart_contracts/price_oracle/contract.py:233
    // self.circuit_breaker_active.value = UInt64(0)
    bytec 6 // "circuit_breaker"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:235
    // log(b"Circuit breaker reset")
    bytec 15 // 0x4369726375697420627265616b6572207265736574
    log
    // smart_contracts/price_oracle/contract.py:236
    // return String("Circuit breaker reset")
    bytec 15 // "Circuit breaker reset"
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.pause_oracle() -> bytes:
pause_oracle:
    // smart_contracts/price_oracle/contract.py:241
    // assert Txn.sender.bytes == self.admin.value, "Only admin can pause"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can pause
    // smart_contracts/price_oracle/contract.py:242
    // self.is_paused.value = UInt64(1)
    bytec 7 // "is_paused"
    intc_1 // 1
    app_global_put
    // smart_contracts/price_oracle/contract.py:244
    // log(b"Oracle paused")
    bytec 16 // 0x4f7261636c6520706175736564
    log
    // smart_contracts/price_oracle/contract.py:245
    // return String("Oracle paused")
    bytec 16 // "Oracle paused"
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.unpause_oracle() -> bytes:
unpause_oracle:
    // smart_contracts/price_oracle/contract.py:250
    // assert Txn.sender.bytes == self.admin.value, "Only admin can unpause"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can unpause
    // smart_contracts/price_oracle/contract.py:251
    // self.is_paused.value = UInt64(0)
    bytec 7 // "is_paused"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:253
    // log(b"Oracle unpaused")
    bytec 17 // 0x4f7261636c6520756e706175736564
    log
    // smart_contracts/price_oracle/contract.py:254
    // return String("Oracle unpaused")
    bytec 17 // "Oracle unpaused"
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.get_oracle_status() -> bytes:
get_oracle_status:
    // smart_contracts/price_oracle/contract.py:260
    // arc4.UInt64(self.is_paused.value),
    intc_0 // 0
    bytec 7 // "is_paused"
    app_global_get_ex
    assert // check self.is_paused exists
    itob
    // smart_contracts/price_oracle/contract.py:261
    // arc4.UInt64(self.circuit_breaker_active.value),
    intc_0 // 0
    bytec 6 // "circuit_breaker"
    app_global_get_ex
    assert // check self.circuit_breaker_active exists
    itob
    // smart_contracts/price_oracle/contract.py:262
    // arc4.UInt64(self.updater_count.value)
    intc_0 // 0
    bytec 8 // "updater_count"
    app_global_get_ex
    assert // check self.updater_count exists
    itob
    // smart_contracts/price_oracle/contract.py:259-263
    // return arc4.Tuple((
    //     arc4.UInt64(self.is_paused.value),
    //     arc4.UInt64(self.circuit_breaker_active.value),
    //     arc4.UInt64(self.updater_count.value)
    // ))
    cover 2
    concat
    swap
    concat
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.remove_threshold() -> bytes:
remove_threshold:
    // smart_contracts/price_oracle/contract.py:268
    // assert Txn.sender.bytes == self.admin.value, "Only admin can remove threshold"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can remove threshold
    // smart_contracts/price_oracle/contract.py:270
    // self.threshold_active.value = UInt64(0)
    bytec 5 // "threshold_active"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:271
    // self.threshold_price.value = UInt64(0)
    bytec 4 // "threshold_price"
    intc_0 // 0
    app_global_put
    // smart_contracts/price_oracle/contract.py:273
    // log(b"Threshold removed")
    pushbytes 0x5468726573686f6c642072656d6f766564
    log
    // smart_contracts/price_oracle/contract.py:274
    // return String("Threshold removed successfully")
    pushbytes "Threshold removed successfully"
    retsub


// smart_contracts.price_oracle.contract.PriceOracle.get_price_history_summary() -> bytes:
get_price_history_summary:
    // smart_contracts/price_oracle/contract.py:303
    // arc4.UInt64(self.token_price.value),  # Current price
    intc_0 // 0
    bytec_2 // "token_price"
    app_global_get_ex
    assert // check self.token_price exists
    itob
    // smart_contracts/price_oracle/contract.py:300-306
    // # In production, would maintain price history
    // # For now, returning current price info
    // return arc4.Tuple((
    //     arc4.UInt64(self.token_price.value),  # Current price
    //     arc4.UInt64(self.token_price.value),  # Max price (simplified)
    //     arc4.UInt64(self.token_price.value)   # Min price (simplified)
    // ))
    dup
    dig 1
    concat
    swap
    concat
    retsub
