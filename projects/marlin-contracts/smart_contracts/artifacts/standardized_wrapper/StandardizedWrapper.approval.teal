#pragma version 10
#pragma typetrack false

// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 10000 5000
    bytecblock 0x151f7c75 "is_paused" "total_supply" "token0_ratio" "token1_ratio" "token0_enabled" "token1_enabled" "admin" "token0_deposited" "token1_deposited" "sy_balance" "yield_rate_bps" 0x5772617070657220706175736564 0x5772617070657220756e706175736564
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@18
    pushbytess 0x4b986d3a 0x5c8152d3 0x268a7abf 0xc96fd357 0x26c1b990 0x4faeb868 0x8088b171 0x46909355 0x2d2a71b5 0x0bc419f1 0x8b9d089f 0x3aaaaab7 0xf1357481 // method "initialize(string,string,uint64)string", method "configure_token(uint64,uint64,uint64)string", method "wrap_tokens(uint64,uint64)string", method "unwrap_tokens(uint64)string", method "get_user_balances()(uint64,uint64,uint64)", method "get_token_config(uint64)(uint64,uint64)", method "get_yield_rate()uint64", method "get_total_supply()uint64", method "calculate_wrap_amount(uint64,uint64)uint64", method "set_yield_rate(uint64)string", method "pause_wrapper()string", method "unpause_wrapper()string", method "is_wrapper_paused()uint64"
    txna ApplicationArgs 0
    match main_initialize_route@5 main_configure_token_route@6 main_wrap_tokens_route@7 main_unwrap_tokens_route@8 main_get_user_balances_route@9 main_get_token_config_route@10 main_get_yield_rate_route@11 main_get_total_supply_route@12 main_calculate_wrap_amount_route@13 main_set_yield_rate_route@14 main_pause_wrapper_route@15 main_unpause_wrapper_route@16 main_is_wrapper_paused_route@17

main_after_if_else@20:
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    intc_0 // 0
    return

main_is_wrapper_paused_route@17:
    // smart_contracts/standardized_wrapper/contract.py:248
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub is_wrapper_paused
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_unpause_wrapper_route@16:
    // smart_contracts/standardized_wrapper/contract.py:239
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub unpause_wrapper
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_pause_wrapper_route@15:
    // smart_contracts/standardized_wrapper/contract.py:230
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub pause_wrapper
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_set_yield_rate_route@14:
    // smart_contracts/standardized_wrapper/contract.py:218
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/standardized_wrapper/contract.py:218
    // @arc4.abimethod
    callsub set_yield_rate
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_calculate_wrap_amount_route@13:
    // smart_contracts/standardized_wrapper/contract.py:203
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/standardized_wrapper/contract.py:203
    // @arc4.abimethod(readonly=True)
    callsub calculate_wrap_amount
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_total_supply_route@12:
    // smart_contracts/standardized_wrapper/contract.py:198
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_total_supply
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_yield_rate_route@11:
    // smart_contracts/standardized_wrapper/contract.py:193
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_yield_rate
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_token_config_route@10:
    // smart_contracts/standardized_wrapper/contract.py:185
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/standardized_wrapper/contract.py:185
    // @arc4.abimethod(readonly=True)
    callsub get_token_config
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_user_balances_route@9:
    // smart_contracts/standardized_wrapper/contract.py:176
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_user_balances
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_unwrap_tokens_route@8:
    // smart_contracts/standardized_wrapper/contract.py:138
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/standardized_wrapper/contract.py:138
    // @arc4.abimethod
    callsub unwrap_tokens
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_wrap_tokens_route@7:
    // smart_contracts/standardized_wrapper/contract.py:103
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/standardized_wrapper/contract.py:103
    // @arc4.abimethod
    callsub wrap_tokens
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_configure_token_route@6:
    // smart_contracts/standardized_wrapper/contract.py:81
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/standardized_wrapper/contract.py:81
    // @arc4.abimethod
    callsub configure_token
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initialize_route@5:
    // smart_contracts/standardized_wrapper/contract.py:56
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    // smart_contracts/standardized_wrapper/contract.py:56
    // @arc4.abimethod
    callsub initialize
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@18:
    // smart_contracts/standardized_wrapper/contract.py:33
    // class StandardizedWrapper(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@20
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.initialize(name: bytes, symbol: bytes, yield_rate_bps: uint64) -> bytes:
initialize:
    // smart_contracts/standardized_wrapper/contract.py:56-62
    // @arc4.abimethod
    // def initialize(
    //     self,
    //     name: String,
    //     symbol: String,
    //     yield_rate_bps: UInt64,
    // ) -> String:
    proto 3 1
    // smart_contracts/standardized_wrapper/contract.py:64
    // assert Txn.sender == Global.creator_address, "Only creator can initialize"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // smart_contracts/standardized_wrapper/contract.py:65
    // assert yield_rate_bps <= UInt64(10000), "Yield rate cannot exceed 100%"
    frame_dig -1
    intc_2 // 10000
    <=
    assert // Yield rate cannot exceed 100%
    // smart_contracts/standardized_wrapper/contract.py:67
    // self.admin.value = Txn.sender.bytes
    bytec 7 // "admin"
    txn Sender
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:68
    // self.name.value = name
    pushbytes "name"
    frame_dig -3
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:69
    // self.symbol.value = symbol
    pushbytes "symbol"
    frame_dig -2
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:70
    // self.yield_rate_bps.value = yield_rate_bps
    bytec 11 // "yield_rate_bps"
    frame_dig -1
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:71
    // self.is_paused.value = UInt64(0)
    bytec_1 // "is_paused"
    intc_0 // 0
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:72
    // self.total_supply.value = UInt64(0)
    bytec_2 // "total_supply"
    intc_0 // 0
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:73
    // self.token0_ratio.value = UInt64(5000)  # 50%
    bytec_3 // "token0_ratio"
    intc_3 // 5000
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:74
    // self.token1_ratio.value = UInt64(5000)  # 50%
    bytec 4 // "token1_ratio"
    intc_3 // 5000
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:75
    // self.token0_enabled.value = UInt64(1)
    bytec 5 // "token0_enabled"
    intc_1 // 1
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:76
    // self.token1_enabled.value = UInt64(1)
    bytec 6 // "token1_enabled"
    intc_1 // 1
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:78
    // log(b"StandardizedWrapper initialized")
    pushbytes 0x5374616e64617264697a65645772617070657220696e697469616c697a6564
    log
    // smart_contracts/standardized_wrapper/contract.py:79
    // return String("Wrapper initialized successfully")
    pushbytes "Wrapper initialized successfully"
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.configure_token(token_index: uint64, ratio: uint64, is_enabled: uint64) -> bytes:
configure_token:
    // smart_contracts/standardized_wrapper/contract.py:81-87
    // @arc4.abimethod
    // def configure_token(
    //     self,
    //     token_index: UInt64,
    //     ratio: UInt64,
    //     is_enabled: UInt64,
    // ) -> String:
    proto 3 1
    // smart_contracts/standardized_wrapper/contract.py:89
    // assert Txn.sender.bytes == self.admin.value, "Only admin can configure"
    txn Sender
    intc_0 // 0
    bytec 7 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can configure
    // smart_contracts/standardized_wrapper/contract.py:90
    // assert ratio <= UInt64(10000), "Ratio cannot exceed 100%"
    frame_dig -2
    intc_2 // 10000
    <=
    assert // Ratio cannot exceed 100%
    // smart_contracts/standardized_wrapper/contract.py:91
    // assert token_index <= UInt64(1), "Only tokens 0 and 1 supported"
    frame_dig -3
    intc_1 // 1
    <=
    assert // Only tokens 0 and 1 supported
    // smart_contracts/standardized_wrapper/contract.py:93
    // if token_index == UInt64(0):
    frame_dig -3
    bnz configure_token_else_body@2
    // smart_contracts/standardized_wrapper/contract.py:94
    // self.token0_ratio.value = ratio
    bytec_3 // "token0_ratio"
    frame_dig -2
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:95
    // self.token0_enabled.value = is_enabled
    bytec 5 // "token0_enabled"
    frame_dig -1
    app_global_put

configure_token_after_if_else@3:
    // smart_contracts/standardized_wrapper/contract.py:100
    // log(b"Token configured - Index: " + op.itob(token_index) + b" Ratio: " + op.itob(ratio))
    frame_dig -3
    itob
    pushbytes 0x546f6b656e20636f6e66696775726564202d20496e6465783a20
    swap
    concat
    pushbytes 0x20526174696f3a20
    concat
    frame_dig -2
    itob
    concat
    log
    // smart_contracts/standardized_wrapper/contract.py:101
    // return String("Token configured successfully")
    pushbytes "Token configured successfully"
    retsub

configure_token_else_body@2:
    // smart_contracts/standardized_wrapper/contract.py:97
    // self.token1_ratio.value = ratio
    bytec 4 // "token1_ratio"
    frame_dig -2
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:98
    // self.token1_enabled.value = is_enabled
    bytec 6 // "token1_enabled"
    frame_dig -1
    app_global_put
    b configure_token_after_if_else@3


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.wrap_tokens(amount0: uint64, amount1: uint64) -> bytes:
wrap_tokens:
    // smart_contracts/standardized_wrapper/contract.py:103-108
    // @arc4.abimethod
    // def wrap_tokens(
    //     self,
    //     amount0: UInt64,
    //     amount1: UInt64,
    // ) -> String:
    proto 2 1
    pushbytes ""
    dup
    // smart_contracts/standardized_wrapper/contract.py:110
    // assert self.is_paused.value == UInt64(0), "Wrapper is paused"
    intc_0 // 0
    bytec_1 // "is_paused"
    app_global_get_ex
    assert // check self.is_paused exists
    !
    assert // Wrapper is paused
    // smart_contracts/standardized_wrapper/contract.py:111
    // assert amount0 > UInt64(0) or amount1 > UInt64(0), "At least one amount must be positive"
    frame_dig -2
    bnz wrap_tokens_bool_true@2
    frame_dig -1
    bz wrap_tokens_bool_false@3

wrap_tokens_bool_true@2:
    intc_1 // 1

wrap_tokens_bool_merge@4:
    // smart_contracts/standardized_wrapper/contract.py:111
    // assert amount0 > UInt64(0) or amount1 > UInt64(0), "At least one amount must be positive"
    assert // At least one amount must be positive
    // smart_contracts/standardized_wrapper/contract.py:113
    // wrapped_amount = UInt64(0)
    intc_0 // 0
    frame_bury 0
    // smart_contracts/standardized_wrapper/contract.py:115-116
    // # Process token 0
    // if amount0 > UInt64(0):
    frame_dig -2
    bz wrap_tokens_after_if_else@6
    // smart_contracts/standardized_wrapper/contract.py:117
    // assert self.token0_enabled.value == UInt64(1), "Token 0 not enabled"
    intc_0 // 0
    bytec 5 // "token0_enabled"
    app_global_get_ex
    assert // check self.token0_enabled exists
    intc_1 // 1
    ==
    assert // Token 0 not enabled
    // smart_contracts/standardized_wrapper/contract.py:118
    // wrapped_0 = (amount0 * self.token0_ratio.value) // UInt64(10000)
    intc_0 // 0
    bytec_3 // "token0_ratio"
    app_global_get_ex
    assert // check self.token0_ratio exists
    frame_dig -2
    *
    intc_2 // 10000
    /
    // smart_contracts/standardized_wrapper/contract.py:120
    // self.token0_deposited[Txn.sender] = self.token0_deposited[Txn.sender] + amount0
    txn Sender
    intc_0 // 0
    bytec 8 // "token0_deposited"
    app_local_get_ex
    assert // check self.token0_deposited exists for account
    frame_dig -2
    +
    txn Sender
    bytec 8 // "token0_deposited"
    uncover 2
    app_local_put
    frame_bury 0

wrap_tokens_after_if_else@6:
    frame_dig 0
    frame_bury 1
    // smart_contracts/standardized_wrapper/contract.py:122-123
    // # Process token 1
    // if amount1 > UInt64(0):
    frame_dig -1
    bz wrap_tokens_after_if_else@8
    // smart_contracts/standardized_wrapper/contract.py:124
    // assert self.token1_enabled.value == UInt64(1), "Token 1 not enabled"
    intc_0 // 0
    bytec 6 // "token1_enabled"
    app_global_get_ex
    assert // check self.token1_enabled exists
    intc_1 // 1
    ==
    assert // Token 1 not enabled
    // smart_contracts/standardized_wrapper/contract.py:125
    // wrapped_1 = (amount1 * self.token1_ratio.value) // UInt64(10000)
    intc_0 // 0
    bytec 4 // "token1_ratio"
    app_global_get_ex
    assert // check self.token1_ratio exists
    frame_dig -1
    *
    intc_2 // 10000
    /
    // smart_contracts/standardized_wrapper/contract.py:126
    // wrapped_amount = wrapped_amount + wrapped_1
    frame_dig 0
    +
    // smart_contracts/standardized_wrapper/contract.py:127
    // self.token1_deposited[Txn.sender] = self.token1_deposited[Txn.sender] + amount1
    txn Sender
    intc_0 // 0
    bytec 9 // "token1_deposited"
    app_local_get_ex
    assert // check self.token1_deposited exists for account
    frame_dig -1
    +
    txn Sender
    bytec 9 // "token1_deposited"
    uncover 2
    app_local_put
    frame_bury 1

wrap_tokens_after_if_else@8:
    frame_dig 1
    // smart_contracts/standardized_wrapper/contract.py:129
    // assert wrapped_amount > UInt64(0), "Wrapped amount must be positive"
    dup
    assert // Wrapped amount must be positive
    // smart_contracts/standardized_wrapper/contract.py:131-132
    // # Update balances
    // self.sy_balance[Txn.sender] = self.sy_balance[Txn.sender] + wrapped_amount
    txn Sender
    intc_0 // 0
    bytec 10 // "sy_balance"
    app_local_get_ex
    assert // check self.sy_balance exists for account
    dig 1
    +
    txn Sender
    bytec 10 // "sy_balance"
    uncover 2
    app_local_put
    // smart_contracts/standardized_wrapper/contract.py:133
    // self.total_supply.value = self.total_supply.value + wrapped_amount
    intc_0 // 0
    bytec_2 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    dig 1
    +
    bytec_2 // "total_supply"
    swap
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:135
    // log(b"Tokens wrapped - Amount: " + op.itob(wrapped_amount))
    itob
    pushbytes 0x546f6b656e732077726170706564202d20416d6f756e743a20
    swap
    concat
    log
    // smart_contracts/standardized_wrapper/contract.py:136
    // return String("Tokens wrapped successfully")
    pushbytes "Tokens wrapped successfully"
    frame_bury 0
    retsub

wrap_tokens_bool_false@3:
    intc_0 // 0
    b wrap_tokens_bool_merge@4


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.unwrap_tokens(amount: uint64) -> bytes:
unwrap_tokens:
    // smart_contracts/standardized_wrapper/contract.py:138-139
    // @arc4.abimethod
    // def unwrap_tokens(self, amount: UInt64) -> String:
    proto 1 1
    pushbytes ""
    dup
    // smart_contracts/standardized_wrapper/contract.py:141
    // assert self.is_paused.value == UInt64(0), "Wrapper is paused"
    intc_0 // 0
    bytec_1 // "is_paused"
    app_global_get_ex
    assert // check self.is_paused exists
    !
    assert // Wrapper is paused
    // smart_contracts/standardized_wrapper/contract.py:142
    // assert amount > UInt64(0), "Amount must be positive"
    frame_dig -1
    assert // Amount must be positive
    // smart_contracts/standardized_wrapper/contract.py:144
    // current_sy_balance = self.sy_balance[Txn.sender]
    txn Sender
    intc_0 // 0
    bytec 10 // "sy_balance"
    app_local_get_ex
    swap
    dup
    uncover 2
    assert // check self.sy_balance exists for account
    // smart_contracts/standardized_wrapper/contract.py:145
    // assert current_sy_balance >= amount, "Insufficient SY balance"
    frame_dig -1
    >=
    assert // Insufficient SY balance
    // smart_contracts/standardized_wrapper/contract.py:147-148
    // # Calculate unwrap amounts based on ratios
    // unwrap_amount0 = UInt64(0)
    intc_0 // 0
    // smart_contracts/standardized_wrapper/contract.py:149
    // unwrap_amount1 = UInt64(0)
    dupn 2
    // smart_contracts/standardized_wrapper/contract.py:151
    // if self.token0_enabled.value == UInt64(1):
    bytec 5 // "token0_enabled"
    app_global_get_ex
    assert // check self.token0_enabled exists
    intc_1 // 1
    ==
    bz unwrap_tokens_after_if_else@2
    // smart_contracts/standardized_wrapper/contract.py:152
    // unwrap_amount0 = (amount * self.token0_ratio.value) // UInt64(10000)
    intc_0 // 0
    bytec_3 // "token0_ratio"
    app_global_get_ex
    assert // check self.token0_ratio exists
    frame_dig -1
    *
    intc_2 // 10000
    /
    frame_bury 3

unwrap_tokens_after_if_else@2:
    // smart_contracts/standardized_wrapper/contract.py:154
    // if self.token1_enabled.value == UInt64(1):
    intc_0 // 0
    bytec 6 // "token1_enabled"
    app_global_get_ex
    assert // check self.token1_enabled exists
    intc_1 // 1
    ==
    bz unwrap_tokens_after_if_else@4
    // smart_contracts/standardized_wrapper/contract.py:155
    // unwrap_amount1 = (amount * self.token1_ratio.value) // UInt64(10000)
    intc_0 // 0
    bytec 4 // "token1_ratio"
    app_global_get_ex
    assert // check self.token1_ratio exists
    frame_dig -1
    *
    intc_2 // 10000
    /
    frame_bury 4

unwrap_tokens_after_if_else@4:
    // smart_contracts/standardized_wrapper/contract.py:157-158
    // # Update balances
    // self.sy_balance[Txn.sender] = current_sy_balance - amount
    frame_dig 2
    frame_dig -1
    -
    txn Sender
    bytec 10 // "sy_balance"
    uncover 2
    app_local_put
    // smart_contracts/standardized_wrapper/contract.py:159
    // self.total_supply.value = self.total_supply.value - amount
    intc_0 // 0
    bytec_2 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    frame_dig -1
    -
    bytec_2 // "total_supply"
    swap
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:161-163
    // # In production, would transfer actual underlying tokens back
    // # For simplicity, just updating deposited amounts
    // if unwrap_amount0 > UInt64(0):
    frame_dig 3
    bz unwrap_tokens_after_if_else@8
    // smart_contracts/standardized_wrapper/contract.py:164
    // current_deposited0 = self.token0_deposited[Txn.sender]
    txn Sender
    intc_0 // 0
    bytec 8 // "token0_deposited"
    app_local_get_ex
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.token0_deposited exists for account
    // smart_contracts/standardized_wrapper/contract.py:165
    // if current_deposited0 >= unwrap_amount0:
    frame_dig 3
    >=
    bz unwrap_tokens_after_if_else@8
    // smart_contracts/standardized_wrapper/contract.py:166
    // self.token0_deposited[Txn.sender] = current_deposited0 - unwrap_amount0
    frame_dig 0
    frame_dig 3
    -
    txn Sender
    bytec 8 // "token0_deposited"
    uncover 2
    app_local_put

unwrap_tokens_after_if_else@8:
    // smart_contracts/standardized_wrapper/contract.py:168
    // if unwrap_amount1 > UInt64(0):
    frame_dig 4
    bz unwrap_tokens_after_if_else@12
    // smart_contracts/standardized_wrapper/contract.py:169
    // current_deposited1 = self.token1_deposited[Txn.sender]
    txn Sender
    intc_0 // 0
    bytec 9 // "token1_deposited"
    app_local_get_ex
    swap
    dup
    cover 2
    frame_bury 1
    assert // check self.token1_deposited exists for account
    // smart_contracts/standardized_wrapper/contract.py:170
    // if current_deposited1 >= unwrap_amount1:
    frame_dig 4
    >=
    bz unwrap_tokens_after_if_else@12
    // smart_contracts/standardized_wrapper/contract.py:171
    // self.token1_deposited[Txn.sender] = current_deposited1 - unwrap_amount1
    frame_dig 1
    frame_dig 4
    -
    txn Sender
    bytec 9 // "token1_deposited"
    uncover 2
    app_local_put

unwrap_tokens_after_if_else@12:
    // smart_contracts/standardized_wrapper/contract.py:173
    // log(b"Tokens unwrapped - Amount: " + op.itob(amount))
    frame_dig -1
    itob
    pushbytes 0x546f6b656e7320756e77726170706564202d20416d6f756e743a20
    swap
    concat
    log
    // smart_contracts/standardized_wrapper/contract.py:174
    // return String("Tokens unwrapped successfully")
    pushbytes "Tokens unwrapped successfully"
    frame_bury 0
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.get_user_balances() -> bytes:
get_user_balances:
    // smart_contracts/standardized_wrapper/contract.py:180
    // arc4.UInt64(self.sy_balance[Txn.sender]),
    txn Sender
    intc_0 // 0
    bytec 10 // "sy_balance"
    app_local_get_ex
    assert // check self.sy_balance exists for account
    itob
    // smart_contracts/standardized_wrapper/contract.py:181
    // arc4.UInt64(self.token0_deposited[Txn.sender]),
    txn Sender
    intc_0 // 0
    bytec 8 // "token0_deposited"
    app_local_get_ex
    assert // check self.token0_deposited exists for account
    itob
    // smart_contracts/standardized_wrapper/contract.py:182
    // arc4.UInt64(self.token1_deposited[Txn.sender])
    txn Sender
    intc_0 // 0
    bytec 9 // "token1_deposited"
    app_local_get_ex
    assert // check self.token1_deposited exists for account
    itob
    // smart_contracts/standardized_wrapper/contract.py:179-183
    // return arc4.Tuple((
    //     arc4.UInt64(self.sy_balance[Txn.sender]),
    //     arc4.UInt64(self.token0_deposited[Txn.sender]),
    //     arc4.UInt64(self.token1_deposited[Txn.sender])
    // ))
    cover 2
    concat
    swap
    concat
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.get_token_config(token_index: uint64) -> bytes:
get_token_config:
    // smart_contracts/standardized_wrapper/contract.py:185-186
    // @arc4.abimethod(readonly=True)
    // def get_token_config(self, token_index: UInt64) -> arc4.Tuple[arc4.UInt64, arc4.UInt64]:
    proto 1 1
    // smart_contracts/standardized_wrapper/contract.py:188
    // if token_index == UInt64(0):
    frame_dig -1
    bnz get_token_config_else_body@2
    // smart_contracts/standardized_wrapper/contract.py:189
    // return arc4.Tuple((arc4.UInt64(self.token0_ratio.value), arc4.UInt64(self.token0_enabled.value)))
    intc_0 // 0
    bytec_3 // "token0_ratio"
    app_global_get_ex
    assert // check self.token0_ratio exists
    itob
    intc_0 // 0
    bytec 5 // "token0_enabled"
    app_global_get_ex
    assert // check self.token0_enabled exists
    itob
    concat
    retsub

get_token_config_else_body@2:
    // smart_contracts/standardized_wrapper/contract.py:191
    // return arc4.Tuple((arc4.UInt64(self.token1_ratio.value), arc4.UInt64(self.token1_enabled.value)))
    intc_0 // 0
    bytec 4 // "token1_ratio"
    app_global_get_ex
    assert // check self.token1_ratio exists
    itob
    intc_0 // 0
    bytec 6 // "token1_enabled"
    app_global_get_ex
    assert // check self.token1_enabled exists
    itob
    concat
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.get_yield_rate() -> uint64:
get_yield_rate:
    // smart_contracts/standardized_wrapper/contract.py:196
    // return self.yield_rate_bps.value
    intc_0 // 0
    bytec 11 // "yield_rate_bps"
    app_global_get_ex
    assert // check self.yield_rate_bps exists
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.get_total_supply() -> uint64:
get_total_supply:
    // smart_contracts/standardized_wrapper/contract.py:201
    // return self.total_supply.value
    intc_0 // 0
    bytec_2 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.calculate_wrap_amount(amount0: uint64, amount1: uint64) -> uint64:
calculate_wrap_amount:
    // smart_contracts/standardized_wrapper/contract.py:203-204
    // @arc4.abimethod(readonly=True)
    // def calculate_wrap_amount(self, amount0: UInt64, amount1: UInt64) -> UInt64:
    proto 2 1
    // smart_contracts/standardized_wrapper/contract.py:206
    // wrapped_amount = UInt64(0)
    intc_0 // 0
    dup
    // smart_contracts/standardized_wrapper/contract.py:208
    // if amount0 > UInt64(0) and self.token0_enabled.value == UInt64(1):
    frame_dig -2
    bz calculate_wrap_amount_after_if_else@3
    intc_0 // 0
    bytec 5 // "token0_enabled"
    app_global_get_ex
    assert // check self.token0_enabled exists
    intc_1 // 1
    ==
    frame_dig 0
    frame_bury 1
    bz calculate_wrap_amount_after_if_else@3
    // smart_contracts/standardized_wrapper/contract.py:209
    // wrapped_0 = (amount0 * self.token0_ratio.value) // UInt64(10000)
    intc_0 // 0
    bytec_3 // "token0_ratio"
    app_global_get_ex
    assert // check self.token0_ratio exists
    frame_dig -2
    *
    intc_2 // 10000
    /
    frame_bury 1

calculate_wrap_amount_after_if_else@3:
    frame_dig 1
    dup
    frame_bury 0
    frame_bury 1
    // smart_contracts/standardized_wrapper/contract.py:212
    // if amount1 > UInt64(0) and self.token1_enabled.value == UInt64(1):
    frame_dig -1
    bz calculate_wrap_amount_after_if_else@6
    intc_0 // 0
    bytec 6 // "token1_enabled"
    app_global_get_ex
    assert // check self.token1_enabled exists
    intc_1 // 1
    ==
    frame_dig 0
    frame_bury 1
    bz calculate_wrap_amount_after_if_else@6
    // smart_contracts/standardized_wrapper/contract.py:213
    // wrapped_1 = (amount1 * self.token1_ratio.value) // UInt64(10000)
    intc_0 // 0
    bytec 4 // "token1_ratio"
    app_global_get_ex
    assert // check self.token1_ratio exists
    frame_dig -1
    *
    intc_2 // 10000
    /
    // smart_contracts/standardized_wrapper/contract.py:214
    // wrapped_amount = wrapped_amount + wrapped_1
    frame_dig 0
    +
    frame_bury 1

calculate_wrap_amount_after_if_else@6:
    frame_dig 1
    // smart_contracts/standardized_wrapper/contract.py:216
    // return wrapped_amount
    frame_bury 0
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.set_yield_rate(new_rate: uint64) -> bytes:
set_yield_rate:
    // smart_contracts/standardized_wrapper/contract.py:218-219
    // @arc4.abimethod
    // def set_yield_rate(self, new_rate: UInt64) -> String:
    proto 1 1
    // smart_contracts/standardized_wrapper/contract.py:221
    // assert Txn.sender.bytes == self.admin.value, "Only admin can set yield rate"
    txn Sender
    intc_0 // 0
    bytec 7 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can set yield rate
    // smart_contracts/standardized_wrapper/contract.py:222
    // assert new_rate <= UInt64(10000), "Yield rate cannot exceed 100%"
    frame_dig -1
    intc_2 // 10000
    <=
    assert // Yield rate cannot exceed 100%
    // smart_contracts/standardized_wrapper/contract.py:224
    // old_rate = self.yield_rate_bps.value
    intc_0 // 0
    bytec 11 // "yield_rate_bps"
    app_global_get_ex
    assert // check self.yield_rate_bps exists
    // smart_contracts/standardized_wrapper/contract.py:225
    // self.yield_rate_bps.value = new_rate
    bytec 11 // "yield_rate_bps"
    frame_dig -1
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:227
    // log(b"Yield rate updated - Old: " + op.itob(old_rate) + b" New: " + op.itob(new_rate))
    itob
    pushbytes 0x5969656c6420726174652075706461746564202d204f6c643a20
    swap
    concat
    pushbytes 0x204e65773a20
    concat
    frame_dig -1
    itob
    concat
    log
    // smart_contracts/standardized_wrapper/contract.py:228
    // return String("Yield rate updated successfully")
    pushbytes "Yield rate updated successfully"
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.pause_wrapper() -> bytes:
pause_wrapper:
    // smart_contracts/standardized_wrapper/contract.py:233
    // assert Txn.sender.bytes == self.admin.value, "Only admin can pause"
    txn Sender
    intc_0 // 0
    bytec 7 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can pause
    // smart_contracts/standardized_wrapper/contract.py:234
    // self.is_paused.value = UInt64(1)
    bytec_1 // "is_paused"
    intc_1 // 1
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:236
    // log(b"Wrapper paused")
    bytec 12 // 0x5772617070657220706175736564
    log
    // smart_contracts/standardized_wrapper/contract.py:237
    // return String("Wrapper paused")
    bytec 12 // "Wrapper paused"
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.unpause_wrapper() -> bytes:
unpause_wrapper:
    // smart_contracts/standardized_wrapper/contract.py:242
    // assert Txn.sender.bytes == self.admin.value, "Only admin can unpause"
    txn Sender
    intc_0 // 0
    bytec 7 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can unpause
    // smart_contracts/standardized_wrapper/contract.py:243
    // self.is_paused.value = UInt64(0)
    bytec_1 // "is_paused"
    intc_0 // 0
    app_global_put
    // smart_contracts/standardized_wrapper/contract.py:245
    // log(b"Wrapper unpaused")
    bytec 13 // 0x5772617070657220756e706175736564
    log
    // smart_contracts/standardized_wrapper/contract.py:246
    // return String("Wrapper unpaused")
    bytec 13 // "Wrapper unpaused"
    retsub


// smart_contracts.standardized_wrapper.contract.StandardizedWrapper.is_wrapper_paused() -> uint64:
is_wrapper_paused:
    // smart_contracts/standardized_wrapper/contract.py:251
    // return self.is_paused.value
    intc_0 // 0
    bytec_1 // "is_paused"
    app_global_get_ex
    assert // check self.is_paused exists
    retsub
