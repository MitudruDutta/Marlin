/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'
import SimulateResponse = modelsv2.SimulateResponse

export const APP_SPEC: Arc56Contract = {"name":"YTAutoConverter","structs":{},"methods":[{"name":"initialize","args":[{"type":"byte[]","name":"oracle_address"},{"type":"byte[]","name":"tokenization_address"},{"type":"byte[]","name":"amm_address"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Initialize the auto converter","events":[],"recommendations":{}},{"name":"configure_conversion","args":[{"type":"uint64","name":"enabled"},{"type":"uint64","name":"threshold_price"},{"type":"uint64","name":"maturity"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Configure automatic conversion for user","events":[],"recommendations":{}},{"name":"deposit_yt_tokens","args":[{"type":"uint64","name":"amount"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Deposit YT tokens for conversion (for testing)","events":[],"recommendations":{}},{"name":"execute_conversion","args":[{"type":"byte[]","name":"user"},{"type":"uint64","name":"min_pt_amount"},{"type":"uint64","name":"deadline"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Execute YT to PT conversion","events":[],"recommendations":{}},{"name":"can_execute_conversion","args":[{"type":"byte[]","name":"user"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Check if conversion can be executed for user","events":[],"recommendations":{}},{"name":"get_user_config","args":[],"returns":{"type":"(uint64,uint64,uint64,uint64)"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get user's conversion configuration","events":[],"recommendations":{}},{"name":"get_user_balances","args":[],"returns":{"type":"(uint64,uint64)"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get user's YT and PT balances","events":[],"recommendations":{}},{"name":"get_conversion_info","args":[],"returns":{"type":"(uint64,uint64,uint64)"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get conversion information","events":[],"recommendations":{}},{"name":"calculate_conversion_output","args":[{"type":"uint64","name":"yt_amount"}],"returns":{"type":"(uint64,uint64)"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Calculate expected PT output for YT input","events":[],"recommendations":{}},{"name":"add_maturity","args":[{"type":"uint64","name":"maturity"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Add a maturity for conversion","events":[],"recommendations":{}},{"name":"remove_maturity","args":[],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Remove user's maturity","events":[],"recommendations":{}},{"name":"set_conversion_fee","args":[{"type":"uint64","name":"new_fee"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Set conversion fee (admin only)","events":[],"recommendations":{}},{"name":"pause_converter","args":[],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Pause the converter (admin only)","events":[],"recommendations":{}},{"name":"unpause_converter","args":[],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Unpause the converter (admin only)","events":[],"recommendations":{}},{"name":"emergency_disable_conversion","args":[],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Emergency disable conversion for user","events":[],"recommendations":{}},{"name":"withdraw_pt_tokens","args":[{"type":"uint64","name":"amount"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Withdraw PT tokens","events":[],"recommendations":{}},{"name":"get_ai_recommendation","args":[{"type":"uint64","name":"yt_amount"},{"type":"uint64","name":"current_price"}],"returns":{"type":"(uint64,string)"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get AI recommendation for conversion (simplified)","events":[],"recommendations":{}},{"name":"update_addresses","args":[{"type":"byte[]","name":"oracle_address"},{"type":"byte[]","name":"tokenization_address"},{"type":"byte[]","name":"amm_address"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Update contract addresses (admin only)","events":[],"recommendations":{}}],"arcs":[22,28],"desc":"AI-powered YT to PT auto converter","networks":{},"state":{"schema":{"global":{"ints":5,"bytes":4},"local":{"ints":6,"bytes":0}},"keys":{"global":{"admin":{"keyType":"AVMString","valueType":"AVMBytes","key":"YWRtaW4="},"oracle_address":{"keyType":"AVMString","valueType":"AVMBytes","key":"b3JhY2xlX2FkZHJlc3M="},"tokenization_address":{"keyType":"AVMString","valueType":"AVMBytes","key":"dG9rZW5pemF0aW9uX2FkZHJlc3M="},"amm_address":{"keyType":"AVMString","valueType":"AVMBytes","key":"YW1tX2FkZHJlc3M="},"conversion_fee":{"keyType":"AVMString","valueType":"AVMUint64","key":"Y29udmVyc2lvbl9mZWU="},"is_paused":{"keyType":"AVMString","valueType":"AVMUint64","key":"aXNfcGF1c2Vk"},"total_conversions":{"keyType":"AVMString","valueType":"AVMUint64","key":"dG90YWxfY29udmVyc2lvbnM="},"max_slippage":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWF4X3NsaXBwYWdl"},"fee_denominator":{"keyType":"AVMString","valueType":"AVMUint64","key":"ZmVlX2Rlbm9taW5hdG9y"}},"local":{"conversion_enabled":{"keyType":"AVMString","valueType":"AVMUint64","key":"Y29udmVyc2lvbl9lbmFibGVk"},"threshold_price":{"keyType":"AVMString","valueType":"AVMUint64","key":"dGhyZXNob2xkX3ByaWNl"},"user_maturity":{"keyType":"AVMString","valueType":"AVMUint64","key":"dXNlcl9tYXR1cml0eQ=="},"conversion_executed":{"keyType":"AVMString","valueType":"AVMUint64","key":"Y29udmVyc2lvbl9leGVjdXRlZA=="},"yt_balance":{"keyType":"AVMString","valueType":"AVMUint64","key":"eXRfYmFsYW5jZQ=="},"pt_balance":{"keyType":"AVMString","valueType":"AVMUint64","key":"cHRfYmFsYW5jZQ=="}},"box":{}},"maps":{"global":{},"local":{},"box":{}}},"bareActions":{"create":["NoOp"],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[1166,2009],"errorMessage":"Amount must be positive"},{"pc":[1289],"errorMessage":"Conversion already executed"},{"pc":[1280],"errorMessage":"Conversion not enabled"},{"pc":[1264],"errorMessage":"Converter is paused"},{"pc":[1798],"errorMessage":"Fee too high (max 10%)"},{"pc":[2021],"errorMessage":"Insufficient PT balance"},{"pc":[1333],"errorMessage":"Insufficient output amount"},{"pc":[1036,1654],"errorMessage":"Maturity must be in future"},{"pc":[1305],"errorMessage":"No YT tokens to convert"},{"pc":[424,466,490,518,542,566,590,618,642,670,690,706,722,738,761,799,827,863],"errorMessage":"OnCompletion is not NoOp"},{"pc":[1901],"errorMessage":"Only admin can pause"},{"pc":[1791],"errorMessage":"Only admin can set fee"},{"pc":[1919],"errorMessage":"Only admin can unpause"},{"pc":[2367],"errorMessage":"Only admin can update addresses"},{"pc":[921],"errorMessage":"Only creator can initialize"},{"pc":[1297],"errorMessage":"Threshold not reached"},{"pc":[1030],"errorMessage":"Threshold price must be positive"},{"pc":[1270],"errorMessage":"Transaction expired"},{"pc":[910],"errorMessage":"can only call when creating"},{"pc":[427,469,493,521,545,569,593,621,645,673,693,709,725,741,764,802,830,866],"errorMessage":"can only call when not creating"},{"pc":[1789,1899,1917,2365],"errorMessage":"check self.admin exists"},{"pc":[1277,1461,1512],"errorMessage":"check self.conversion_enabled exists for account"},{"pc":[1287,1473,1536],"errorMessage":"check self.conversion_executed exists for account"},{"pc":[1309,1569,1619,1802],"errorMessage":"check self.conversion_fee exists"},{"pc":[1317,1627],"errorMessage":"check self.fee_denominator exists"},{"pc":[1262,1581],"errorMessage":"check self.is_paused exists"},{"pc":[1345,1562,2016],"errorMessage":"check self.pt_balance exists for account"},{"pc":[1296,1498,1520,2166],"errorMessage":"check self.threshold_price exists for account"},{"pc":[1366,1575],"errorMessage":"check self.total_conversions exists"},{"pc":[1528],"errorMessage":"check self.user_maturity exists for account"},{"pc":[1172,1303,1486,1554],"errorMessage":"check self.yt_balance exists for account"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLl9fYWxnb3B5X2VudHJ5cG9pbnRfd2l0aF9pbml0KCkgLT4gdWludDY0OgptYWluOgogICAgaW50Y2Jsb2NrIDAgMSAxMDAwMAogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1ICJjb252ZXJzaW9uX2ZlZSIgInl0X2JhbGFuY2UiICJhZG1pbiIgImlzX3BhdXNlZCIgImNvbnZlcnNpb25fZW5hYmxlZCIgInRocmVzaG9sZF9wcmljZSIgImNvbnZlcnNpb25fZXhlY3V0ZWQiICJwdF9iYWxhbmNlIiAidG90YWxfY29udmVyc2lvbnMiICJ1c2VyX21hdHVyaXR5IiAiZmVlX2Rlbm9taW5hdG9yIiAib3JhY2xlX2FkZHJlc3MiICJ0b2tlbml6YXRpb25fYWRkcmVzcyIgImFtbV9hZGRyZXNzIiAweDQzNmY2ZTc2NjU3Mjc0NjU3MjIwNzA2MTc1NzM2NTY0IDB4NDM2ZjZlNzY2NTcyNzQ2NTcyMjA3NTZlNzA2MTc1NzM2NTY0CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NDQtNDUKICAgIC8vICMgQ29uc3RhbnRzCiAgICAvLyBzZWxmLm1heF9zbGlwcGFnZSA9IFVJbnQ2NCg1MDApICAjIDUlCiAgICBwdXNoYnl0ZXMgIm1heF9zbGlwcGFnZSIKICAgIHB1c2hpbnQgNTAwIC8vIDUwMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo0NgogICAgLy8gc2VsZi5mZWVfZGVub21pbmF0b3IgPSBVSW50NjQoMTAwMDApCiAgICBieXRlYyAxMSAvLyAiZmVlX2Rlbm9taW5hdG9yIgogICAgaW50Y18yIC8vIDEwMDAwCiAgICBhcHBfZ2xvYmFsX3B1dAoKbWFpbl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYmFyZV9yb3V0aW5nQDIzCiAgICBwdXNoYnl0ZXNzIDB4NmE2OWRmNWQgMHg2YjlhYWYzNCAweDM5ZTg4YzU5IDB4NmFkN2MzMDIgMHhhNjU3ZTJmOSAweDY2NzZkOTUxIDB4ZmU0ZWRmZDkgMHg2YmQxNDI4YyAweDU0ZmJlYzM1IDB4NTk5MWEzMDEgMHhjNzMwZDIyYyAweDFhZjAzNzAwIDB4NDUyNjU0YjQgMHhkMzI4MjA0MyAweDExNjM4ZWMyIDB4YzAyMDVkYWQgMHg2OWZmMDE1MCAweDcxNjEzNTBmIC8vIG1ldGhvZCAiaW5pdGlhbGl6ZShieXRlW10sYnl0ZVtdLGJ5dGVbXSlzdHJpbmciLCBtZXRob2QgImNvbmZpZ3VyZV9jb252ZXJzaW9uKHVpbnQ2NCx1aW50NjQsdWludDY0KXN0cmluZyIsIG1ldGhvZCAiZGVwb3NpdF95dF90b2tlbnModWludDY0KXN0cmluZyIsIG1ldGhvZCAiZXhlY3V0ZV9jb252ZXJzaW9uKGJ5dGVbXSx1aW50NjQsdWludDY0KXN0cmluZyIsIG1ldGhvZCAiY2FuX2V4ZWN1dGVfY29udmVyc2lvbihieXRlW10pdWludDY0IiwgbWV0aG9kICJnZXRfdXNlcl9jb25maWcoKSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJnZXRfdXNlcl9iYWxhbmNlcygpKHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJnZXRfY29udmVyc2lvbl9pbmZvKCkodWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJjYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXQodWludDY0KSh1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiYWRkX21hdHVyaXR5KHVpbnQ2NClzdHJpbmciLCBtZXRob2QgInJlbW92ZV9tYXR1cml0eSgpc3RyaW5nIiwgbWV0aG9kICJzZXRfY29udmVyc2lvbl9mZWUodWludDY0KXN0cmluZyIsIG1ldGhvZCAicGF1c2VfY29udmVydGVyKClzdHJpbmciLCBtZXRob2QgInVucGF1c2VfY29udmVydGVyKClzdHJpbmciLCBtZXRob2QgImVtZXJnZW5jeV9kaXNhYmxlX2NvbnZlcnNpb24oKXN0cmluZyIsIG1ldGhvZCAid2l0aGRyYXdfcHRfdG9rZW5zKHVpbnQ2NClzdHJpbmciLCBtZXRob2QgImdldF9haV9yZWNvbW1lbmRhdGlvbih1aW50NjQsdWludDY0KSh1aW50NjQsc3RyaW5nKSIsIG1ldGhvZCAidXBkYXRlX2FkZHJlc3NlcyhieXRlW10sYnl0ZVtdLGJ5dGVbXSlzdHJpbmciCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2luaXRpYWxpemVfcm91dGVANSBtYWluX2NvbmZpZ3VyZV9jb252ZXJzaW9uX3JvdXRlQDYgbWFpbl9kZXBvc2l0X3l0X3Rva2Vuc19yb3V0ZUA3IG1haW5fZXhlY3V0ZV9jb252ZXJzaW9uX3JvdXRlQDggbWFpbl9jYW5fZXhlY3V0ZV9jb252ZXJzaW9uX3JvdXRlQDkgbWFpbl9nZXRfdXNlcl9jb25maWdfcm91dGVAMTAgbWFpbl9nZXRfdXNlcl9iYWxhbmNlc19yb3V0ZUAxMSBtYWluX2dldF9jb252ZXJzaW9uX2luZm9fcm91dGVAMTIgbWFpbl9jYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXRfcm91dGVAMTMgbWFpbl9hZGRfbWF0dXJpdHlfcm91dGVAMTQgbWFpbl9yZW1vdmVfbWF0dXJpdHlfcm91dGVAMTUgbWFpbl9zZXRfY29udmVyc2lvbl9mZWVfcm91dGVAMTYgbWFpbl9wYXVzZV9jb252ZXJ0ZXJfcm91dGVAMTcgbWFpbl91bnBhdXNlX2NvbnZlcnRlcl9yb3V0ZUAxOCBtYWluX2VtZXJnZW5jeV9kaXNhYmxlX2NvbnZlcnNpb25fcm91dGVAMTkgbWFpbl93aXRoZHJhd19wdF90b2tlbnNfcm91dGVAMjAgbWFpbl9nZXRfYWlfcmVjb21tZW5kYXRpb25fcm91dGVAMjEgbWFpbl91cGRhdGVfYWRkcmVzc2VzX3JvdXRlQDIyCgptYWluX2FmdGVyX2lmX2Vsc2VAMjU6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgaW50Y18wIC8vIDAKICAgIHJldHVybgoKbWFpbl91cGRhdGVfYWRkcmVzc2VzX3JvdXRlQDIyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMxMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgdXBkYXRlX2FkZHJlc3NlcwogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0X2FpX3JlY29tbWVuZGF0aW9uX3JvdXRlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI5NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjk1CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGNhbGxzdWIgZ2V0X2FpX3JlY29tbWVuZGF0aW9uCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3dpdGhkcmF3X3B0X3Rva2Vuc19yb3V0ZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI2OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIHdpdGhkcmF3X3B0X3Rva2VucwogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZW1lcmdlbmN5X2Rpc2FibGVfY29udmVyc2lvbl9yb3V0ZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNjAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGVtZXJnZW5jeV9kaXNhYmxlX2NvbnZlcnNpb24KICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3VucGF1c2VfY29udmVydGVyX3JvdXRlQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI1MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgdW5wYXVzZV9jb252ZXJ0ZXIKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3BhdXNlX2NvbnZlcnRlcl9yb3V0ZUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNDIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIHBhdXNlX2NvbnZlcnRlcgogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc2V0X2NvbnZlcnNpb25fZmVlX3JvdXRlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIzMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjMwCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgc2V0X2NvbnZlcnNpb25fZmVlCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9yZW1vdmVfbWF0dXJpdHlfcm91dGVAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjIyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiByZW1vdmVfbWF0dXJpdHkKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2FkZF9tYXR1cml0eV9yb3V0ZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMTEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGFkZF9tYXR1cml0eQogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY2FsY3VsYXRlX2NvbnZlcnNpb25fb3V0cHV0X3JvdXRlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE5NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTk2CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGNhbGxzdWIgY2FsY3VsYXRlX2NvbnZlcnNpb25fb3V0cHV0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF9jb252ZXJzaW9uX2luZm9fcm91dGVAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTg3CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBnZXRfY29udmVyc2lvbl9pbmZvCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF91c2VyX2JhbGFuY2VzX3JvdXRlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE3OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgZ2V0X3VzZXJfYmFsYW5jZXMKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0X3VzZXJfY29uZmlnX3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE2OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgZ2V0X3VzZXJfY29uZmlnCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2Nhbl9leGVjdXRlX2NvbnZlcnNpb25fcm91dGVAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNTAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEKICAgIC8vIGNsYXNzIFlUQXV0b0NvbnZlcnRlcihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNTAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBjYW5fZXhlY3V0ZV9jb252ZXJzaW9uCiAgICBpdG9iCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2V4ZWN1dGVfY29udmVyc2lvbl9yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjEwNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjEwNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGV4ZWN1dGVfY29udmVyc2lvbgogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVwb3NpdF95dF90b2tlbnNfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo5NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6OTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgY2FsbHN1YiBkZXBvc2l0X3l0X3Rva2VucwogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY29uZmlndXJlX2NvbnZlcnNpb25fcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo3NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NzcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgY2FsbHN1YiBjb25maWd1cmVfY29udmVyc2lvbgogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faW5pdGlhbGl6ZV9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjU2CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMxCiAgICAvLyBjbGFzcyBZVEF1dG9Db252ZXJ0ZXIoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo1NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGluaXRpYWxpemUKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2JhcmVfcm91dGluZ0AyMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMQogICAgLy8gY2xhc3MgWVRBdXRvQ29udmVydGVyKEFSQzRDb250cmFjdCk6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDI1CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIuaW5pdGlhbGl6ZShvcmFjbGVfYWRkcmVzczogYnl0ZXMsIHRva2VuaXphdGlvbl9hZGRyZXNzOiBieXRlcywgYW1tX2FkZHJlc3M6IGJ5dGVzKSAtPiBieXRlczoKaW5pdGlhbGl6ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo1Ni02MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICAvLyBkZWYgaW5pdGlhbGl6ZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIG9yYWNsZV9hZGRyZXNzOiBCeXRlcywKICAgIC8vICAgICB0b2tlbml6YXRpb25fYWRkcmVzczogQnl0ZXMsCiAgICAvLyAgICAgYW1tX2FkZHJlc3M6IEJ5dGVzLAogICAgLy8gKSAtPiBTdHJpbmc6CiAgICBwcm90byAzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo2NAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgIk9ubHkgY3JlYXRvciBjYW4gaW5pdGlhbGl6ZSIKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IGNyZWF0b3IgY2FuIGluaXRpYWxpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo2NgogICAgLy8gc2VsZi5hZG1pbi52YWx1ZSA9IFR4bi5zZW5kZXIuYnl0ZXMKICAgIGJ5dGVjXzMgLy8gImFkbWluIgogICAgdHhuIFNlbmRlcgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo2NwogICAgLy8gc2VsZi5vcmFjbGVfYWRkcmVzcy52YWx1ZSA9IG9yYWNsZV9hZGRyZXNzCiAgICBieXRlYyAxMiAvLyAib3JhY2xlX2FkZHJlc3MiCiAgICBmcmFtZV9kaWcgLTMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NjgKICAgIC8vIHNlbGYudG9rZW5pemF0aW9uX2FkZHJlc3MudmFsdWUgPSB0b2tlbml6YXRpb25fYWRkcmVzcwogICAgYnl0ZWMgMTMgLy8gInRva2VuaXphdGlvbl9hZGRyZXNzIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjY5CiAgICAvLyBzZWxmLmFtbV9hZGRyZXNzLnZhbHVlID0gYW1tX2FkZHJlc3MKICAgIGJ5dGVjIDE0IC8vICJhbW1fYWRkcmVzcyIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo3MAogICAgLy8gc2VsZi5jb252ZXJzaW9uX2ZlZS52YWx1ZSA9IFVJbnQ2NCgzMCkgICMgMC4zJQogICAgYnl0ZWNfMSAvLyAiY29udmVyc2lvbl9mZWUiCiAgICBwdXNoaW50IDMwIC8vIDMwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjcxCiAgICAvLyBzZWxmLmlzX3BhdXNlZC52YWx1ZSA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgNCAvLyAiaXNfcGF1c2VkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NzIKICAgIC8vIHNlbGYudG90YWxfY29udmVyc2lvbnMudmFsdWUgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDkgLy8gInRvdGFsX2NvbnZlcnNpb25zIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6NzQKICAgIC8vIGxvZyhiIllUQXV0b0NvbnZlcnRlciBpbml0aWFsaXplZCIpCiAgICBwdXNoYnl0ZXMgMHg1OTU0NDE3NTc0NmY0MzZmNmU3NjY1NzI3NDY1NzIyMDY5NmU2OTc0Njk2MTZjNjk3YTY1NjQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5Ojc1CiAgICAvLyByZXR1cm4gU3RyaW5nKCJBdXRvIGNvbnZlcnRlciBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkiKQogICAgcHVzaGJ5dGVzICJBdXRvIGNvbnZlcnRlciBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmNvbmZpZ3VyZV9jb252ZXJzaW9uKGVuYWJsZWQ6IHVpbnQ2NCwgdGhyZXNob2xkX3ByaWNlOiB1aW50NjQsIG1hdHVyaXR5OiB1aW50NjQpIC0+IGJ5dGVzOgpjb25maWd1cmVfY29udmVyc2lvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo3Ny04MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICAvLyBkZWYgY29uZmlndXJlX2NvbnZlcnNpb24oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBlbmFibGVkOiBVSW50NjQsCiAgICAvLyAgICAgdGhyZXNob2xkX3ByaWNlOiBVSW50NjQsCiAgICAvLyAgICAgbWF0dXJpdHk6IFVJbnQ2NCwKICAgIC8vICkgLT4gU3RyaW5nOgogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6ODUKICAgIC8vIGFzc2VydCB0aHJlc2hvbGRfcHJpY2UgPiBVSW50NjQoMCksICJUaHJlc2hvbGQgcHJpY2UgbXVzdCBiZSBwb3NpdGl2ZSIKICAgIGZyYW1lX2RpZyAtMgogICAgYXNzZXJ0IC8vIFRocmVzaG9sZCBwcmljZSBtdXN0IGJlIHBvc2l0aXZlCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6ODYKICAgIC8vIGFzc2VydCBtYXR1cml0eSA+IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wLCAiTWF0dXJpdHkgbXVzdCBiZSBpbiBmdXR1cmUiCiAgICBmcmFtZV9kaWcgLTEKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgID4KICAgIGFzc2VydCAvLyBNYXR1cml0eSBtdXN0IGJlIGluIGZ1dHVyZQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5Ojg4CiAgICAvLyBzZWxmLmNvbnZlcnNpb25fZW5hYmxlZFtUeG4uc2VuZGVyXSA9IGVuYWJsZWQKICAgIHR4biBTZW5kZXIKICAgIGJ5dGVjIDUgLy8gImNvbnZlcnNpb25fZW5hYmxlZCIKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5Ojg5CiAgICAvLyBzZWxmLnRocmVzaG9sZF9wcmljZVtUeG4uc2VuZGVyXSA9IHRocmVzaG9sZF9wcmljZQogICAgdHhuIFNlbmRlcgogICAgYnl0ZWMgNiAvLyAidGhyZXNob2xkX3ByaWNlIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6OTAKICAgIC8vIHNlbGYudXNlcl9tYXR1cml0eVtUeG4uc2VuZGVyXSA9IG1hdHVyaXR5CiAgICB0eG4gU2VuZGVyCiAgICBieXRlYyAxMCAvLyAidXNlcl9tYXR1cml0eSIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjkxCiAgICAvLyBzZWxmLmNvbnZlcnNpb25fZXhlY3V0ZWRbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkgICMgUmVzZXQgZXhlY3V0aW9uIHN0YXR1cwogICAgdHhuIFNlbmRlcgogICAgYnl0ZWMgNyAvLyAiY29udmVyc2lvbl9leGVjdXRlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6OTMKICAgIC8vIGxvZyhiIkNvbnZlcnNpb24gY29uZmlndXJlZCAtIEVuYWJsZWQ6ICIgKyBvcC5pdG9iKGVuYWJsZWQpICsgYiIgVGhyZXNob2xkOiAiICsgb3AuaXRvYih0aHJlc2hvbGRfcHJpY2UpKQogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg0MzZmNmU3NjY1NzI3MzY5NmY2ZTIwNjM2ZjZlNjY2OTY3NzU3MjY1NjQyMDJkMjA0NTZlNjE2MjZjNjU2NDNhMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4MjA1NDY4NzI2NTczNjg2ZjZjNjQzYTIwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo5NAogICAgLy8gcmV0dXJuIFN0cmluZygiQ29udmVyc2lvbiBjb25maWd1cmVkIHN1Y2Nlc3NmdWxseSIpCiAgICBwdXNoYnl0ZXMgIkNvbnZlcnNpb24gY29uZmlndXJlZCBzdWNjZXNzZnVsbHkiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmRlcG9zaXRfeXRfdG9rZW5zKGFtb3VudDogdWludDY0KSAtPiBieXRlczoKZGVwb3NpdF95dF90b2tlbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6OTYtOTcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIGRlcG9zaXRfeXRfdG9rZW5zKHNlbGYsIGFtb3VudDogVUludDY0KSAtPiBTdHJpbmc6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTo5OQogICAgLy8gYXNzZXJ0IGFtb3VudCA+IFVJbnQ2NCgwKSwgIkFtb3VudCBtdXN0IGJlIHBvc2l0aXZlIgogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NlcnQgLy8gQW1vdW50IG11c3QgYmUgcG9zaXRpdmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxMDEKICAgIC8vIHNlbGYueXRfYmFsYW5jZVtUeG4uc2VuZGVyXSA9IHNlbGYueXRfYmFsYW5jZVtUeG4uc2VuZGVyXSArIGFtb3VudAogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInl0X2JhbGFuY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi55dF9iYWxhbmNlIGV4aXN0cyBmb3IgYWNjb3VudAogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICB0eG4gU2VuZGVyCiAgICBieXRlY18yIC8vICJ5dF9iYWxhbmNlIgogICAgdW5jb3ZlciAyCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTAzCiAgICAvLyBsb2coYiJZVCB0b2tlbnMgZGVwb3NpdGVkIC0gQW1vdW50OiAiICsgb3AuaXRvYihhbW91bnQpKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg1OTU0MjA3NDZmNmI2NTZlNzMyMDY0NjU3MDZmNzM2OTc0NjU2NDIwMmQyMDQxNmQ2Zjc1NmU3NDNhMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTA0CiAgICAvLyByZXR1cm4gU3RyaW5nKCJZVCB0b2tlbnMgZGVwb3NpdGVkIHN1Y2Nlc3NmdWxseSIpCiAgICBwdXNoYnl0ZXMgIllUIHRva2VucyBkZXBvc2l0ZWQgc3VjY2Vzc2Z1bGx5IgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5leGVjdXRlX2NvbnZlcnNpb24odXNlcjogYnl0ZXMsIG1pbl9wdF9hbW91bnQ6IHVpbnQ2NCwgZGVhZGxpbmU6IHVpbnQ2NCkgLT4gYnl0ZXM6CmV4ZWN1dGVfY29udmVyc2lvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxMDYtMTEyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBleGVjdXRlX2NvbnZlcnNpb24oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB1c2VyOiBCeXRlcywKICAgIC8vICAgICBtaW5fcHRfYW1vdW50OiBVSW50NjQsCiAgICAvLyAgICAgZGVhZGxpbmU6IFVJbnQ2NCwKICAgIC8vICkgLT4gU3RyaW5nOgogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTE0CiAgICAvLyBhc3NlcnQgc2VsZi5pc19wYXVzZWQudmFsdWUgPT0gVUludDY0KDApLCAiQ29udmVydGVyIGlzIHBhdXNlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJpc19wYXVzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfcGF1c2VkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIENvbnZlcnRlciBpcyBwYXVzZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxMTUKICAgIC8vIGFzc2VydCBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCA8PSBkZWFkbGluZSwgIlRyYW5zYWN0aW9uIGV4cGlyZWQiCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBmcmFtZV9kaWcgLTEKICAgIDw9CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gZXhwaXJlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjEyMAogICAgLy8gYXNzZXJ0IHNlbGYuY29udmVyc2lvbl9lbmFibGVkW1R4bi5zZW5kZXJdID09IFVJbnQ2NCgxKSwgIkNvbnZlcnNpb24gbm90IGVuYWJsZWQiCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAiY29udmVyc2lvbl9lbmFibGVkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY29udmVyc2lvbl9lbmFibGVkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gQ29udmVyc2lvbiBub3QgZW5hYmxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjEyMQogICAgLy8gYXNzZXJ0IHNlbGYuY29udmVyc2lvbl9leGVjdXRlZFtUeG4uc2VuZGVyXSA9PSBVSW50NjQoMCksICJDb252ZXJzaW9uIGFscmVhZHkgZXhlY3V0ZWQiCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAiY29udmVyc2lvbl9leGVjdXRlZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZXhlY3V0ZWQgZXhpc3RzIGZvciBhY2NvdW50CiAgICAhCiAgICBhc3NlcnQgLy8gQ29udmVyc2lvbiBhbHJlYWR5IGV4ZWN1dGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTIzLTEyNQogICAgLy8gIyBDaGVjayBpZiB0aHJlc2hvbGQgaXMgcmVhY2hlZCAoc2ltcGxpZmllZCAtIHdvdWxkIGNhbGwgb3JhY2xlIGNvbnRyYWN0KQogICAgLy8gIyBGb3IgZGVtbywgYXNzdW1lIHRocmVzaG9sZCBpcyByZWFjaGVkIGlmIHRocmVzaG9sZF9wcmljZSA+IDAKICAgIC8vIHVzZXJfdGhyZXNob2xkID0gc2VsZi50aHJlc2hvbGRfcHJpY2VbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJ0aHJlc2hvbGRfcHJpY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50aHJlc2hvbGRfcHJpY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTI2CiAgICAvLyBhc3NlcnQgdXNlcl90aHJlc2hvbGQgPiBVSW50NjQoMCksICJUaHJlc2hvbGQgbm90IHJlYWNoZWQiCiAgICBhc3NlcnQgLy8gVGhyZXNob2xkIG5vdCByZWFjaGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTI4LTEyOQogICAgLy8gIyBDaGVjayBZVCBiYWxhbmNlCiAgICAvLyB1c2VyX3l0X2JhbGFuY2UgPSBzZWxmLnl0X2JhbGFuY2VbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ5dF9iYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYueXRfYmFsYW5jZSBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxMzAKICAgIC8vIGFzc2VydCB1c2VyX3l0X2JhbGFuY2UgPiBVSW50NjQoMCksICJObyBZVCB0b2tlbnMgdG8gY29udmVydCIKICAgIGR1cAogICAgYXNzZXJ0IC8vIE5vIFlUIHRva2VucyB0byBjb252ZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTMyLTEzMwogICAgLy8gIyBDYWxjdWxhdGUgY29udmVyc2lvbiBmZWUKICAgIC8vIGZlZV9hbW91bnQgPSAodXNlcl95dF9iYWxhbmNlICogc2VsZi5jb252ZXJzaW9uX2ZlZS52YWx1ZSkgLy8gc2VsZi5mZWVfZGVub21pbmF0b3IKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJjb252ZXJzaW9uX2ZlZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jb252ZXJzaW9uX2ZlZSBleGlzdHMKICAgIGRpZyAxCiAgICAqCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTEgLy8gImZlZV9kZW5vbWluYXRvciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5mZWVfZGVub21pbmF0b3IgZXhpc3RzCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTM0CiAgICAvLyBjb252ZXJzaW9uX2Ftb3VudCA9IHVzZXJfeXRfYmFsYW5jZSAtIGZlZV9hbW91bnQKICAgIGRpZyAxCiAgICBzd2FwCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjg3LTI4OAogICAgLy8gIyBTaW11bGF0ZSBzbGlwcGFnZSBhbmQgbWFya2V0IGltcGFjdAogICAgLy8gc2xpcHBhZ2VfZmFjdG9yID0gVUludDY0KDk5NTApICAjIDAuNSUgc2xpcHBhZ2UKICAgIHB1c2hpbnQgOTk1MCAvLyA5OTUwCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjg5CiAgICAvLyBtYXJrZXRfcmF0ZSA9IChhbW91bnQgKiBzbGlwcGFnZV9mYWN0b3IpIC8vIFVJbnQ2NCgxMDAwMCkKICAgICoKICAgIGludGNfMiAvLyAxMDAwMAogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI5MQogICAgLy8gYXNzZXJ0IG1hcmtldF9yYXRlID49IG1pbl9vdXRwdXQsICJJbnN1ZmZpY2llbnQgb3V0cHV0IGFtb3VudCIKICAgIGR1cAogICAgZnJhbWVfZGlnIC0yCiAgICA+PQogICAgYXNzZXJ0IC8vIEluc3VmZmljaWVudCBvdXRwdXQgYW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTM5LTE0MAogICAgLy8gIyBVcGRhdGUgYmFsYW5jZXMKICAgIC8vIHNlbGYueXRfYmFsYW5jZVtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgwKSAgIyBBbGwgWVQgdG9rZW5zIGNvbnZlcnRlZAogICAgdHhuIFNlbmRlcgogICAgYnl0ZWNfMiAvLyAieXRfYmFsYW5jZSIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTQxCiAgICAvLyBzZWxmLnB0X2JhbGFuY2VbVHhuLnNlbmRlcl0gPSBzZWxmLnB0X2JhbGFuY2VbVHhuLnNlbmRlcl0gKyByZWNlaXZlZF9wdAogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDggLy8gInB0X2JhbGFuY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wdF9iYWxhbmNlIGV4aXN0cyBmb3IgYWNjb3VudAogICAgZGlnIDEKICAgICsKICAgIHR4biBTZW5kZXIKICAgIGJ5dGVjIDggLy8gInB0X2JhbGFuY2UiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNDIKICAgIC8vIHNlbGYuY29udmVyc2lvbl9leGVjdXRlZFtUeG4uc2VuZGVyXSA9IFVJbnQ2NCgxKQogICAgdHhuIFNlbmRlcgogICAgYnl0ZWMgNyAvLyAiY29udmVyc2lvbl9leGVjdXRlZCIKICAgIGludGNfMSAvLyAxCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTQ0LTE0NQogICAgLy8gIyBVcGRhdGUgZ2xvYmFsIHN0YXRzCiAgICAvLyBzZWxmLnRvdGFsX2NvbnZlcnNpb25zLnZhbHVlID0gc2VsZi50b3RhbF9jb252ZXJzaW9ucy52YWx1ZSArIFVJbnQ2NCgxKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gInRvdGFsX2NvbnZlcnNpb25zIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2NvbnZlcnNpb25zIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ5dGVjIDkgLy8gInRvdGFsX2NvbnZlcnNpb25zIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNDcKICAgIC8vIGxvZyhiIkNvbnZlcnNpb24gZXhlY3V0ZWQgLSBZVDogIiArIG9wLml0b2IodXNlcl95dF9iYWxhbmNlKSArIGIiIFBUOiAiICsgb3AuaXRvYihyZWNlaXZlZF9wdCkpCiAgICBzd2FwCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg0MzZmNmU3NjY1NzI3MzY5NmY2ZTIwNjU3ODY1NjM3NTc0NjU2NDIwMmQyMDU5NTQzYTIwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDIwNTA1NDNhMjAKICAgIGNvbmNhdAogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNDgKICAgIC8vIHJldHVybiBTdHJpbmcoIkNvbnZlcnNpb24gZXhlY3V0ZWQgc3VjY2Vzc2Z1bGx5IikKICAgIHB1c2hieXRlcyAiQ29udmVyc2lvbiBleGVjdXRlZCBzdWNjZXNzZnVsbHkiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmNhbl9leGVjdXRlX2NvbnZlcnNpb24odXNlcjogYnl0ZXMpIC0+IHVpbnQ2NDoKY2FuX2V4ZWN1dGVfY29udmVyc2lvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNTAtMTUxCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBjYW5fZXhlY3V0ZV9jb252ZXJzaW9uKHNlbGYsIHVzZXI6IEJ5dGVzKSAtPiBVSW50NjQ6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNTMtMTU0CiAgICAvLyAjIFNpbXBsaWZpZWQgY2hlY2sgdXNpbmcgc2VuZGVyJ3MgZGF0YQogICAgLy8gaWYgc2VsZi5jb252ZXJzaW9uX2VuYWJsZWRbVHhuLnNlbmRlcl0gPT0gVUludDY0KDApOgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImNvbnZlcnNpb25fZW5hYmxlZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZW5hYmxlZCBleGlzdHMgZm9yIGFjY291bnQKICAgIGJueiBjYW5fZXhlY3V0ZV9jb252ZXJzaW9uX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE1NQogICAgLy8gcmV0dXJuIFVJbnQ2NCgwKSAgIyBOb3QgZW5hYmxlZAogICAgaW50Y18wIC8vIDAKICAgIHJldHN1YgoKY2FuX2V4ZWN1dGVfY29udmVyc2lvbl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTU3CiAgICAvLyBpZiBzZWxmLmNvbnZlcnNpb25fZXhlY3V0ZWRbVHhuLnNlbmRlcl0gPT0gVUludDY0KDEpOgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gImNvbnZlcnNpb25fZXhlY3V0ZWQiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jb252ZXJzaW9uX2V4ZWN1dGVkIGV4aXN0cyBmb3IgYWNjb3VudAogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBieiBjYW5fZXhlY3V0ZV9jb252ZXJzaW9uX2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE1OAogICAgLy8gcmV0dXJuIFVJbnQ2NCgwKSAgIyBBbHJlYWR5IGV4ZWN1dGVkCiAgICBpbnRjXzAgLy8gMAogICAgcmV0c3ViCgpjYW5fZXhlY3V0ZV9jb252ZXJzaW9uX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNjAKICAgIC8vIGlmIHNlbGYueXRfYmFsYW5jZVtUeG4uc2VuZGVyXSA9PSBVSW50NjQoMCk6CiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAieXRfYmFsYW5jZSIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnl0X2JhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICBibnogY2FuX2V4ZWN1dGVfY29udmVyc2lvbl9hZnRlcl9pZl9lbHNlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNjEKICAgIC8vIHJldHVybiBVSW50NjQoMCkgICMgTm8gWVQgdG9rZW5zCiAgICBpbnRjXzAgLy8gMAogICAgcmV0c3ViCgpjYW5fZXhlY3V0ZV9jb252ZXJzaW9uX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNjMKICAgIC8vIGlmIHNlbGYudGhyZXNob2xkX3ByaWNlW1R4bi5zZW5kZXJdID09IFVJbnQ2NCgwKToKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJ0aHJlc2hvbGRfcHJpY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50aHJlc2hvbGRfcHJpY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICBibnogY2FuX2V4ZWN1dGVfY29udmVyc2lvbl9hZnRlcl9pZl9lbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNjQKICAgIC8vIHJldHVybiBVSW50NjQoMCkgICMgTm8gdGhyZXNob2xkIHNldAogICAgaW50Y18wIC8vIDAKICAgIHJldHN1YgoKY2FuX2V4ZWN1dGVfY29udmVyc2lvbl9hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTY2LTE2NwogICAgLy8gIyBJbiBwcm9kdWN0aW9uLCB3b3VsZCBjaGVjayBvcmFjbGUgZm9yIGFjdHVhbCB0aHJlc2hvbGQgc3RhdHVzCiAgICAvLyByZXR1cm4gVUludDY0KDEpICAjIENhbiBleGVjdXRlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5nZXRfdXNlcl9jb25maWcoKSAtPiBieXRlczoKZ2V0X3VzZXJfY29uZmlnOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE3MwogICAgLy8gYXJjNC5VSW50NjQoc2VsZi5jb252ZXJzaW9uX2VuYWJsZWRbVHhuLnNlbmRlcl0pLAogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImNvbnZlcnNpb25fZW5hYmxlZCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZW5hYmxlZCBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNzQKICAgIC8vIGFyYzQuVUludDY0KHNlbGYudGhyZXNob2xkX3ByaWNlW1R4bi5zZW5kZXJdKSwKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJ0aHJlc2hvbGRfcHJpY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50aHJlc2hvbGRfcHJpY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTc1CiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLnVzZXJfbWF0dXJpdHlbVHhuLnNlbmRlcl0pLAogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vICJ1c2VyX21hdHVyaXR5IgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudXNlcl9tYXR1cml0eSBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNzYKICAgIC8vIGFyYzQuVUludDY0KHNlbGYuY29udmVyc2lvbl9leGVjdXRlZFtUeG4uc2VuZGVyXSkKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJjb252ZXJzaW9uX2V4ZWN1dGVkIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY29udmVyc2lvbl9leGVjdXRlZCBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxNzItMTc3CiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoCiAgICAvLyAgICAgYXJjNC5VSW50NjQoc2VsZi5jb252ZXJzaW9uX2VuYWJsZWRbVHhuLnNlbmRlcl0pLAogICAgLy8gICAgIGFyYzQuVUludDY0KHNlbGYudGhyZXNob2xkX3ByaWNlW1R4bi5zZW5kZXJdKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLnVzZXJfbWF0dXJpdHlbVHhuLnNlbmRlcl0pLAogICAgLy8gICAgIGFyYzQuVUludDY0KHNlbGYuY29udmVyc2lvbl9leGVjdXRlZFtUeG4uc2VuZGVyXSkKICAgIC8vICkpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmdldF91c2VyX2JhbGFuY2VzKCkgLT4gYnl0ZXM6CmdldF91c2VyX2JhbGFuY2VzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE4MwogICAgLy8gYXJjNC5VSW50NjQoc2VsZi55dF9iYWxhbmNlW1R4bi5zZW5kZXJdKSwKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ5dF9iYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYueXRfYmFsYW5jZSBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxODQKICAgIC8vIGFyYzQuVUludDY0KHNlbGYucHRfYmFsYW5jZVtUeG4uc2VuZGVyXSkKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vICJwdF9iYWxhbmNlIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucHRfYmFsYW5jZSBleGlzdHMgZm9yIGFjY291bnQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxODItMTg1CiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoCiAgICAvLyAgICAgYXJjNC5VSW50NjQoc2VsZi55dF9iYWxhbmNlW1R4bi5zZW5kZXJdKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLnB0X2JhbGFuY2VbVHhuLnNlbmRlcl0pCiAgICAvLyApKQogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLmdldF9jb252ZXJzaW9uX2luZm8oKSAtPiBieXRlczoKZ2V0X2NvbnZlcnNpb25faW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxOTEKICAgIC8vIGFyYzQuVUludDY0KHNlbGYuY29udmVyc2lvbl9mZWUudmFsdWUpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImNvbnZlcnNpb25fZmVlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZmVlIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE5MgogICAgLy8gYXJjNC5VSW50NjQoc2VsZi50b3RhbF9jb252ZXJzaW9ucy52YWx1ZSksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAidG90YWxfY29udmVyc2lvbnMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudG90YWxfY29udmVyc2lvbnMgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTkzCiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLmlzX3BhdXNlZC52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJpc19wYXVzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfcGF1c2VkIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjE5MC0xOTQKICAgIC8vIHJldHVybiBhcmM0LlR1cGxlKCgKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLmNvbnZlcnNpb25fZmVlLnZhbHVlKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLnRvdGFsX2NvbnZlcnNpb25zLnZhbHVlKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NChzZWxmLmlzX3BhdXNlZC52YWx1ZSkKICAgIC8vICkpCiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5jYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXQoeXRfYW1vdW50OiB1aW50NjQpIC0+IGJ5dGVzOgpjYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MTk2LTE5NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgY2FsY3VsYXRlX2NvbnZlcnNpb25fb3V0cHV0KHNlbGYsIHl0X2Ftb3VudDogVUludDY0KSAtPiBhcmM0LlR1cGxlW2FyYzQuVUludDY0LCBhcmM0LlVJbnQ2NF06CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToxOTkKICAgIC8vIGlmIHl0X2Ftb3VudCA9PSBVSW50NjQoMCk6CiAgICBmcmFtZV9kaWcgLTEKICAgIGJueiBjYWxjdWxhdGVfY29udmVyc2lvbl9vdXRwdXRfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjAwCiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoYXJjNC5VSW50NjQoMCksIGFyYzQuVUludDY0KDApKSkKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICByZXRzdWIKCmNhbGN1bGF0ZV9jb252ZXJzaW9uX291dHB1dF9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjAyCiAgICAvLyBmZWVfYW1vdW50ID0gKHl0X2Ftb3VudCAqIHNlbGYuY29udmVyc2lvbl9mZWUudmFsdWUpIC8vIHNlbGYuZmVlX2Rlbm9taW5hdG9yCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAiY29udmVyc2lvbl9mZWUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY29udmVyc2lvbl9mZWUgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgICoKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX2Rlbm9taW5hdG9yIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9kZW5vbWluYXRvciBleGlzdHMKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMDMKICAgIC8vIGNvbnZlcnNpb25fYW1vdW50ID0geXRfYW1vdW50IC0gZmVlX2Ftb3VudAogICAgZnJhbWVfZGlnIC0xCiAgICBkaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIwNS0yMDYKICAgIC8vICMgU2ltcGxpZmllZCBjb252ZXJzaW9uIHJhdGUgKDE6MSBtaW51cyBzbGlwcGFnZSkKICAgIC8vIHNsaXBwYWdlX2Ftb3VudCA9IChjb252ZXJzaW9uX2Ftb3VudCAqIFVJbnQ2NCg1MCkpIC8vIFVJbnQ2NCgxMDAwMCkgICMgMC41JSBzbGlwcGFnZQogICAgZHVwCiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICAqCiAgICBpbnRjXzIgLy8gMTAwMDAKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMDcKICAgIC8vIGV4cGVjdGVkX3B0ID0gY29udmVyc2lvbl9hbW91bnQgLSBzbGlwcGFnZV9hbW91bnQKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMDkKICAgIC8vIHJldHVybiBhcmM0LlR1cGxlKChhcmM0LlVJbnQ2NChleHBlY3RlZF9wdCksIGFyYzQuVUludDY0KGZlZV9hbW91bnQpKSkKICAgIGl0b2IKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5hZGRfbWF0dXJpdHkobWF0dXJpdHk6IHVpbnQ2NCkgLT4gYnl0ZXM6CmFkZF9tYXR1cml0eToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMTEtMjEyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBhZGRfbWF0dXJpdHkoc2VsZiwgbWF0dXJpdHk6IFVJbnQ2NCkgLT4gU3RyaW5nOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjE0CiAgICAvLyBhc3NlcnQgbWF0dXJpdHkgPiBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCwgIk1hdHVyaXR5IG11c3QgYmUgaW4gZnV0dXJlIgogICAgZnJhbWVfZGlnIC0xCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICA+CiAgICBhc3NlcnQgLy8gTWF0dXJpdHkgbXVzdCBiZSBpbiBmdXR1cmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMTYtMjE3CiAgICAvLyAjIEZvciBzaW1wbGljaXR5LCBqdXN0IHVwZGF0ZSB1c2VyJ3MgbWF0dXJpdHkKICAgIC8vIHNlbGYudXNlcl9tYXR1cml0eVtUeG4uc2VuZGVyXSA9IG1hdHVyaXR5CiAgICB0eG4gU2VuZGVyCiAgICBieXRlYyAxMCAvLyAidXNlcl9tYXR1cml0eSIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIxOQogICAgLy8gbG9nKGIiTWF0dXJpdHkgYWRkZWQgLSBWYWx1ZTogIiArIG9wLml0b2IobWF0dXJpdHkpKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg0ZDYxNzQ3NTcyNjk3NDc5MjA2MTY0NjQ2NTY0MjAyZDIwNTY2MTZjNzU2NTNhMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjIwCiAgICAvLyByZXR1cm4gU3RyaW5nKCJNYXR1cml0eSBhZGRlZCBzdWNjZXNzZnVsbHkiKQogICAgcHVzaGJ5dGVzICJNYXR1cml0eSBhZGRlZCBzdWNjZXNzZnVsbHkiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLnJlbW92ZV9tYXR1cml0eSgpIC0+IGJ5dGVzOgpyZW1vdmVfbWF0dXJpdHk6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjI1CiAgICAvLyBzZWxmLnVzZXJfbWF0dXJpdHlbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGVjIDEwIC8vICJ1c2VyX21hdHVyaXR5IgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMjcKICAgIC8vIGxvZyhiIk1hdHVyaXR5IHJlbW92ZWQiKQogICAgcHVzaGJ5dGVzIDB4NGQ2MTc0NzU3MjY5NzQ3OTIwNzI2NTZkNmY3NjY1NjQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIyOAogICAgLy8gcmV0dXJuIFN0cmluZygiTWF0dXJpdHkgcmVtb3ZlZCBzdWNjZXNzZnVsbHkiKQogICAgcHVzaGJ5dGVzICJNYXR1cml0eSByZW1vdmVkIHN1Y2Nlc3NmdWxseSIKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIuc2V0X2NvbnZlcnNpb25fZmVlKG5ld19mZWU6IHVpbnQ2NCkgLT4gYnl0ZXM6CnNldF9jb252ZXJzaW9uX2ZlZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMzAtMjMxCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBzZXRfY29udmVyc2lvbl9mZWUoc2VsZiwgbmV3X2ZlZTogVUludDY0KSAtPiBTdHJpbmc6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyMzMKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyLmJ5dGVzID09IHNlbGYuYWRtaW4udmFsdWUsICJPbmx5IGFkbWluIGNhbiBzZXQgZmVlIgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gImFkbWluIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFkbWluIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IGFkbWluIGNhbiBzZXQgZmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjM0CiAgICAvLyBhc3NlcnQgbmV3X2ZlZSA8PSBVSW50NjQoMTAwMCksICJGZWUgdG9vIGhpZ2ggKG1heCAxMCUpIgogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDEwMDAgLy8gMTAwMAogICAgPD0KICAgIGFzc2VydCAvLyBGZWUgdG9vIGhpZ2ggKG1heCAxMCUpCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjM2CiAgICAvLyBvbGRfZmVlID0gc2VsZi5jb252ZXJzaW9uX2ZlZS52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImNvbnZlcnNpb25fZmVlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbnZlcnNpb25fZmVlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIzNwogICAgLy8gc2VsZi5jb252ZXJzaW9uX2ZlZS52YWx1ZSA9IG5ld19mZWUKICAgIGJ5dGVjXzEgLy8gImNvbnZlcnNpb25fZmVlIgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjIzOQogICAgLy8gbG9nKGIiQ29udmVyc2lvbiBmZWUgdXBkYXRlZCAtIE9sZDogIiArIG9wLml0b2Iob2xkX2ZlZSkgKyBiIiBOZXc6ICIgKyBvcC5pdG9iKG5ld19mZWUpKQogICAgaXRvYgogICAgcHVzaGJ5dGVzIDB4NDM2ZjZlNzY2NTcyNzM2OTZmNmUyMDY2NjU2NTIwNzU3MDY0NjE3NDY1NjQyMDJkMjA0ZjZjNjQzYTIwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDIwNGU2NTc3M2EyMAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjQwCiAgICAvLyByZXR1cm4gU3RyaW5nKCJDb252ZXJzaW9uIGZlZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseSIpCiAgICBwdXNoYnl0ZXMgIkNvbnZlcnNpb24gZmVlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5wYXVzZV9jb252ZXJ0ZXIoKSAtPiBieXRlczoKcGF1c2VfY29udmVydGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI0NQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIuYnl0ZXMgPT0gc2VsZi5hZG1pbi52YWx1ZSwgIk9ubHkgYWRtaW4gY2FuIHBhdXNlIgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gImFkbWluIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFkbWluIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IGFkbWluIGNhbiBwYXVzZQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI0NgogICAgLy8gc2VsZi5pc19wYXVzZWQudmFsdWUgPSBVSW50NjQoMSkKICAgIGJ5dGVjIDQgLy8gImlzX3BhdXNlZCIKICAgIGludGNfMSAvLyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI0OAogICAgLy8gbG9nKGIiQ29udmVydGVyIHBhdXNlZCIpCiAgICBieXRlYyAxNSAvLyAweDQzNmY2ZTc2NjU3Mjc0NjU3MjIwNzA2MTc1NzM2NTY0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNDkKICAgIC8vIHJldHVybiBTdHJpbmcoIkNvbnZlcnRlciBwYXVzZWQiKQogICAgYnl0ZWMgMTUgLy8gIkNvbnZlcnRlciBwYXVzZWQiCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMueXRfYXV0b19jb252ZXJ0ZXIuY29udHJhY3QuWVRBdXRvQ29udmVydGVyLnVucGF1c2VfY29udmVydGVyKCkgLT4gYnl0ZXM6CnVucGF1c2VfY29udmVydGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI1NAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIuYnl0ZXMgPT0gc2VsZi5hZG1pbi52YWx1ZSwgIk9ubHkgYWRtaW4gY2FuIHVucGF1c2UiCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiYWRtaW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYWRtaW4gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgYWRtaW4gY2FuIHVucGF1c2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNTUKICAgIC8vIHNlbGYuaXNfcGF1c2VkLnZhbHVlID0gVUludDY0KDApCiAgICBieXRlYyA0IC8vICJpc19wYXVzZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNTcKICAgIC8vIGxvZyhiIkNvbnZlcnRlciB1bnBhdXNlZCIpCiAgICBieXRlYyAxNiAvLyAweDQzNmY2ZTc2NjU3Mjc0NjU3MjIwNzU2ZTcwNjE3NTczNjU2NAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjU4CiAgICAvLyByZXR1cm4gU3RyaW5nKCJDb252ZXJ0ZXIgdW5wYXVzZWQiKQogICAgYnl0ZWMgMTYgLy8gIkNvbnZlcnRlciB1bnBhdXNlZCIKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIuZW1lcmdlbmN5X2Rpc2FibGVfY29udmVyc2lvbigpIC0+IGJ5dGVzOgplbWVyZ2VuY3lfZGlzYWJsZV9jb252ZXJzaW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI2MwogICAgLy8gc2VsZi5jb252ZXJzaW9uX2VuYWJsZWRbVHhuLnNlbmRlcl0gPSBVSW50NjQoMCkKICAgIHR4biBTZW5kZXIKICAgIGJ5dGVjIDUgLy8gImNvbnZlcnNpb25fZW5hYmxlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjY1CiAgICAvLyBsb2coYiJDb252ZXJzaW9uIGVtZXJnZW5jeSBkaXNhYmxlZCIpCiAgICBwdXNoYnl0ZXMgMHg0MzZmNmU3NjY1NzI3MzY5NmY2ZTIwNjU2ZDY1NzI2NzY1NmU2Mzc5MjA2NDY5NzM2MTYyNmM2NTY0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNjYKICAgIC8vIHJldHVybiBTdHJpbmcoIkNvbnZlcnNpb24gZGlzYWJsZWQgZm9yIGVtZXJnZW5jeSIpCiAgICBwdXNoYnl0ZXMgIkNvbnZlcnNpb24gZGlzYWJsZWQgZm9yIGVtZXJnZW5jeSIKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIud2l0aGRyYXdfcHRfdG9rZW5zKGFtb3VudDogdWludDY0KSAtPiBieXRlczoKd2l0aGRyYXdfcHRfdG9rZW5zOgogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI2OC0yNjkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIHdpdGhkcmF3X3B0X3Rva2VucyhzZWxmLCBhbW91bnQ6IFVJbnQ2NCkgLT4gU3RyaW5nOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MjcxCiAgICAvLyBhc3NlcnQgYW1vdW50ID4gVUludDY0KDApLCAiQW1vdW50IG11c3QgYmUgcG9zaXRpdmUiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2VydCAvLyBBbW91bnQgbXVzdCBiZSBwb3NpdGl2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjI3MwogICAgLy8gY3VycmVudF9wdF9iYWxhbmNlID0gc2VsZi5wdF9iYWxhbmNlW1R4bi5zZW5kZXJdCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOCAvLyAicHRfYmFsYW5jZSIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnB0X2JhbGFuY2UgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjc0CiAgICAvLyBhc3NlcnQgY3VycmVudF9wdF9iYWxhbmNlID49IGFtb3VudCwgIkluc3VmZmljaWVudCBQVCBiYWxhbmNlIgogICAgZHVwCiAgICBmcmFtZV9kaWcgLTEKICAgID49CiAgICBhc3NlcnQgLy8gSW5zdWZmaWNpZW50IFBUIGJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyNzYKICAgIC8vIHNlbGYucHRfYmFsYW5jZVtUeG4uc2VuZGVyXSA9IGN1cnJlbnRfcHRfYmFsYW5jZSAtIGFtb3VudAogICAgZnJhbWVfZGlnIC0xCiAgICAtCiAgICB0eG4gU2VuZGVyCiAgICBieXRlYyA4IC8vICJwdF9iYWxhbmNlIgogICAgdW5jb3ZlciAyCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjc4CiAgICAvLyBsb2coYiJQVCB0b2tlbnMgd2l0aGRyYXduIC0gQW1vdW50OiAiICsgb3AuaXRvYihhbW91bnQpKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg1MDU0MjA3NDZmNmI2NTZlNzMyMDc3Njk3NDY4NjQ3MjYxNzc2ZTIwMmQyMDQxNmQ2Zjc1NmU3NDNhMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjc5CiAgICAvLyByZXR1cm4gU3RyaW5nKCJQVCB0b2tlbnMgd2l0aGRyYXduIHN1Y2Nlc3NmdWxseSIpCiAgICBwdXNoYnl0ZXMgIlBUIHRva2VucyB3aXRoZHJhd24gc3VjY2Vzc2Z1bGx5IgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnl0X2F1dG9fY29udmVydGVyLmNvbnRyYWN0LllUQXV0b0NvbnZlcnRlci5nZXRfYWlfcmVjb21tZW5kYXRpb24oeXRfYW1vdW50OiB1aW50NjQsIGN1cnJlbnRfcHJpY2U6IHVpbnQ2NCkgLT4gYnl0ZXM6CmdldF9haV9yZWNvbW1lbmRhdGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyOTUtMjk2CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfYWlfcmVjb21tZW5kYXRpb24oc2VsZiwgeXRfYW1vdW50OiBVSW50NjQsIGN1cnJlbnRfcHJpY2U6IFVJbnQ2NCkgLT4gYXJjNC5UdXBsZVthcmM0LlVJbnQ2NCwgYXJjNC5TdHJpbmddOgogICAgcHJvdG8gMiAxCiAgICBwdXNoYnl0ZXMgIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weToyOTgKICAgIC8vIGlmIHl0X2Ftb3VudCA9PSBVSW50NjQoMCk6CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiBnZXRfYWlfcmVjb21tZW5kYXRpb25fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6Mjk5CiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoYXJjNC5VSW50NjQoMCksIGFyYzQuU3RyaW5nKCJObyBZVCB0b2tlbnMgdG8gY29udmVydCIpKSkKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAxNzRlNmYyMDU5NTQyMDc0NmY2YjY1NmU3MzIwNzQ2ZjIwNjM2ZjZlNzY2NTcyNzQKICAgIHN3YXAKICAgIHJldHN1YgoKZ2V0X2FpX3JlY29tbWVuZGF0aW9uX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMDEKICAgIC8vIHVzZXJfdGhyZXNob2xkID0gc2VsZi50aHJlc2hvbGRfcHJpY2VbVHhuLnNlbmRlcl0KICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJ0aHJlc2hvbGRfcHJpY2UiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGhyZXNob2xkX3ByaWNlIGV4aXN0cyBmb3IgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMwMwogICAgLy8gaWYgY3VycmVudF9wcmljZSA+PSB1c2VyX3RocmVzaG9sZDoKICAgIGZyYW1lX2RpZyAtMQogICAgPD0KICAgIGJ6IGdldF9haV9yZWNvbW1lbmRhdGlvbl9lbHNlX2JvZHlANAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMwNAogICAgLy8gcmV0dXJuIGFyYzQuVHVwbGUoKGFyYzQuVUludDY0KDEpLCBhcmM0LlN0cmluZygiUmVjb21tZW5kIGNvbnZlcnNpb24gLSB0aHJlc2hvbGQgcmVhY2hlZCIpKSkKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDEwMDBhMDAyODUyNjU2MzZmNmQ2ZDY1NmU2NDIwNjM2ZjZlNzY2NTcyNzM2OTZmNmUyMDJkMjA3NDY4NzI2NTczNjg2ZjZjNjQyMDcyNjU2MTYzNjg2NTY0CiAgICBzd2FwCiAgICByZXRzdWIKCmdldF9haV9yZWNvbW1lbmRhdGlvbl9lbHNlX2JvZHlANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMDYKICAgIC8vIHJlbWFpbmluZ191cHNpZGUgPSAoKHVzZXJfdGhyZXNob2xkIC0gY3VycmVudF9wcmljZSkgKiBVSW50NjQoMTAwKSkgLy8gY3VycmVudF9wcmljZQogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2RpZyAtMQogICAgLQogICAgcHVzaGludCAxMDAgLy8gMTAwCiAgICAqCiAgICBmcmFtZV9kaWcgLTEKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMDcKICAgIC8vIGlmIHJlbWFpbmluZ191cHNpZGUgPCBVSW50NjQoNSk6ICAjIExlc3MgdGhhbiA1JSB0byB0aHJlc2hvbGQKICAgIHB1c2hpbnQgNSAvLyA1CiAgICA8CiAgICBieiBnZXRfYWlfcmVjb21tZW5kYXRpb25fZWxzZV9ib2R5QDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMDgKICAgIC8vIHJldHVybiBhcmM0LlR1cGxlKChhcmM0LlVJbnQ2NCgxKSwgYXJjNC5TdHJpbmcoIlJlY29tbWVuZCBjb252ZXJzaW9uIC0gY2xvc2UgdG8gdGhyZXNob2xkIikpKQogICAgcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMTAwMGEwMDI5NTI2NTYzNmY2ZDZkNjU2ZTY0MjA2MzZmNmU3NjY1NzI3MzY5NmY2ZTIwMmQyMDYzNmM2ZjczNjUyMDc0NmYyMDc0Njg3MjY1NzM2ODZmNmM2NAogICAgc3dhcAogICAgcmV0c3ViCgpnZXRfYWlfcmVjb21tZW5kYXRpb25fZWxzZV9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzEwCiAgICAvLyByZXR1cm4gYXJjNC5UdXBsZSgoYXJjNC5VSW50NjQoMCksIGFyYzQuU3RyaW5nKCJIb2xkIFlUIHRva2VucyAtIHRocmVzaG9sZCBub3QgcmVhY2hlZCIpKSkKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAyNjQ4NmY2YzY0MjA1OTU0MjA3NDZmNmI2NTZlNzMyMDJkMjA3NDY4NzI2NTczNjg2ZjZjNjQyMDZlNmY3NDIwNzI2NTYxNjM2ODY1NjQKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy55dF9hdXRvX2NvbnZlcnRlci5jb250cmFjdC5ZVEF1dG9Db252ZXJ0ZXIudXBkYXRlX2FkZHJlc3NlcyhvcmFjbGVfYWRkcmVzczogYnl0ZXMsIHRva2VuaXphdGlvbl9hZGRyZXNzOiBieXRlcywgYW1tX2FkZHJlc3M6IGJ5dGVzKSAtPiBieXRlczoKdXBkYXRlX2FkZHJlc3NlczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMTItMzE4CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiB1cGRhdGVfYWRkcmVzc2VzKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgb3JhY2xlX2FkZHJlc3M6IEJ5dGVzLAogICAgLy8gICAgIHRva2VuaXphdGlvbl9hZGRyZXNzOiBCeXRlcywKICAgIC8vICAgICBhbW1fYWRkcmVzczogQnl0ZXMsCiAgICAvLyApIC0+IFN0cmluZzoKICAgIHByb3RvIDMgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMyMAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIuYnl0ZXMgPT0gc2VsZi5hZG1pbi52YWx1ZSwgIk9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZGRyZXNzZXMiCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiYWRtaW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYWRtaW4gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZGRyZXNzZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMjIKICAgIC8vIHNlbGYub3JhY2xlX2FkZHJlc3MudmFsdWUgPSBvcmFjbGVfYWRkcmVzcwogICAgYnl0ZWMgMTIgLy8gIm9yYWNsZV9hZGRyZXNzIgogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMyMwogICAgLy8gc2VsZi50b2tlbml6YXRpb25fYWRkcmVzcy52YWx1ZSA9IHRva2VuaXphdGlvbl9hZGRyZXNzCiAgICBieXRlYyAxMyAvLyAidG9rZW5pemF0aW9uX2FkZHJlc3MiCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMveXRfYXV0b19jb252ZXJ0ZXIvY29udHJhY3QucHk6MzI0CiAgICAvLyBzZWxmLmFtbV9hZGRyZXNzLnZhbHVlID0gYW1tX2FkZHJlc3MKICAgIGJ5dGVjIDE0IC8vICJhbW1fYWRkcmVzcyIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy95dF9hdXRvX2NvbnZlcnRlci9jb250cmFjdC5weTozMjYKICAgIC8vIGxvZyhiIkNvbnRyYWN0IGFkZHJlc3NlcyB1cGRhdGVkIikKICAgIHB1c2hieXRlcyAweDQzNmY2ZTc0NzI2MTYzNzQyMDYxNjQ2NDcyNjU3MzczNjU3MzIwNzU3MDY0NjE3NDY1NjQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3l0X2F1dG9fY29udmVydGVyL2NvbnRyYWN0LnB5OjMyNwogICAgLy8gcmV0dXJuIFN0cmluZygiQ29udHJhY3QgYWRkcmVzc2VzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IikKICAgIHB1c2hieXRlcyAiQ29udHJhY3QgYWRkcmVzc2VzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IgogICAgcmV0c3ViCg==","clear":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"},"byteCode":{"approval":"CiADAAGQTiYRBBUffHUOY29udmVyc2lvbl9mZWUKeXRfYmFsYW5jZQVhZG1pbglpc19wYXVzZWQSY29udmVyc2lvbl9lbmFibGVkD3RocmVzaG9sZF9wcmljZRNjb252ZXJzaW9uX2V4ZWN1dGVkCnB0X2JhbGFuY2URdG90YWxfY29udmVyc2lvbnMNdXNlcl9tYXR1cml0eQ9mZWVfZGVub21pbmF0b3IOb3JhY2xlX2FkZHJlc3MUdG9rZW5pemF0aW9uX2FkZHJlc3MLYW1tX2FkZHJlc3MQQ29udmVydGVyIHBhdXNlZBJDb252ZXJ0ZXIgdW5wYXVzZWQxGEAAFoAMbWF4X3NsaXBwYWdlgfQDZycLJGcxG0ECaIISBGpp310Ea5qvNAQ56IxZBGrXwwIEplfi+QRmdtlRBP5O39kEa9FCjARU++w1BFmRowEExzDSLAQa8DcABEUmVLQE0yggQwQRY47CBMAgXa0Eaf8BUARxYTUPNhoAjhIBuQGVAXkBUwE8ASwBHAEMAPgA3ADEAKgAkAB4AGAARAAsAAIiQzEZFEQxGEQ2GgFXAgA2GgJXAgA2GgNXAgCIB3RJFRZXBgJMUChMULAjQzEZFEQxGEQ2GgEXNhoCF4gGWChMULAjQzEZFEQxGEQ2GgEXiAXfSRUWVwYCTFAoTFCwI0MxGRREMRhEiAV9SRUWVwYCTFAoTFCwI0MxGRREMRhEiAVTSRUWVwYCTFAoTFCwI0MxGRREMRhEiAUpSRUWVwYCTFAoTFCwI0MxGRREMRhENhoBF4gEnEkVFlcGAkxQKExQsCNDMRkURDEYRIgES0kVFlcGAkxQKExQsCNDMRkURDEYRDYaAReIA+FJFRZXBgJMUChMULAjQzEZFEQxGEQ2GgEXiAOMKExQsCNDMRkURDEYRIgDZShMULAjQzEZFEQxGESIA0QoTFCwI0MxGRREMRhEiAMJKExQsCNDMRkURDEYRDYaAVcCAIgCvRYoTFCwI0MxGRREMRhENhoBVwIANhoCFzYaAxeIAdlJFRZXBgJMUChMULAjQzEZFEQxGEQ2GgEXiAFfSRUWVwYCTFAoTFCwI0MxGRREMRhENhoBFzYaAhc2GgMXiACzSRUWVwYCTFAoTFCwI0MxGRREMRhENhoBVwIANhoCVwIANhoDVwIAiAAZSRUWVwYCTFAoTFCwI0MxGUD+GDEYFEQjQ4oDATEAMgkSRCsxAGcnDIv9ZycNi/5nJw6L/2cpgR5nJwQiZycJImeAG1lUQXV0b0NvbnZlcnRlciBpbml0aWFsaXplZLCAJ0F1dG8gY29udmVydGVyIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseYmKAwGL/kSL/zIHDUQxACcFi/1mMQAnBov+ZjEAJwqL/2YxACcHImaL/RaAIUNvbnZlcnNpb24gY29uZmlndXJlZCAtIEVuYWJsZWQ6IExQgAwgVGhyZXNob2xkOiBQi/4WULCAIkNvbnZlcnNpb24gY29uZmlndXJlZCBzdWNjZXNzZnVsbHmJigEBi/9EMQAiKmNEi/8IMQAqTwJmi/8WgB5ZVCB0b2tlbnMgZGVwb3NpdGVkIC0gQW1vdW50OiBMULCAIFlUIHRva2VucyBkZXBvc2l0ZWQgc3VjY2Vzc2Z1bGx5iYoDASInBGVEFEQyB4v/DkQxACInBWNEIxJEMQAiJwdjRBREMQAiJwZjREQxACIqY0RJRCIpZURLAQsiJwtlRApLAUwJgd5NCyQKSYv+D0QxACoiZjEAIicIY0RLAQgxACcITwJmMQAnByNmIicJZUQjCCcJTGdMFoAaQ29udmVyc2lvbiBleGVjdXRlZCAtIFlUOiBMUIAFIFBUOiBQTBZQsIAgQ29udmVyc2lvbiBleGVjdXRlZCBzdWNjZXNzZnVsbHmJigEBMQAiJwVjREAAAiKJMQAiJwdjRCMSQQACIokxACIqY0RAAAIiiTEAIicGY0RAAAIiiSOJMQAiJwVjRBYxACInBmNEFjEAIicKY0QWMQAiJwdjRBZPA08DUE8CUExQiTEAIipjRBYxACInCGNEFlCJIillRBYiJwllRBYiJwRlRBZOAlBMUImKAQGL/0AAE4AQAAAAAAAAAAAAAAAAAAAAAIkiKWVEi/8LIicLZUQKi/9LAQlJgTILJAoJFkwWUImKAQGL/zIHDUQxACcKi/9mi/8WgBhNYXR1cml0eSBhZGRlZCAtIFZhbHVlOiBMULCAG01hdHVyaXR5IGFkZGVkIHN1Y2Nlc3NmdWxseYkxACcKImaAEE1hdHVyaXR5IHJlbW92ZWSwgB1NYXR1cml0eSByZW1vdmVkIHN1Y2Nlc3NmdWxseYmKAQExACIrZUQSRIv/gegHDkQiKWVEKYv/ZxaAHkNvbnZlcnNpb24gZmVlIHVwZGF0ZWQgLSBPbGQ6IExQgAYgTmV3OiBQi/8WULCAI0NvbnZlcnNpb24gZmVlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5iTEAIitlRBJEJwQjZycPsCcPiTEAIitlRBJEJwQiZycQsCcQiTEAJwUiZoAdQ29udmVyc2lvbiBlbWVyZ2VuY3kgZGlzYWJsZWSwgCFDb252ZXJzaW9uIGRpc2FibGVkIGZvciBlbWVyZ2VuY3mJigEBi/9EMQAiJwhjREmL/w9Ei/8JMQAnCE8CZov/FoAeUFQgdG9rZW5zIHdpdGhkcmF3biAtIEFtb3VudDogTFCwgCBQVCB0b2tlbnMgd2l0aGRyYXduIHN1Y2Nlc3NmdWxseYmKAgGAAIv+QAAngCMAAAAAAAAAAAAKABdObyBZVCB0b2tlbnMgdG8gY29udmVydEyJMQAiJwZjTElOAowARIv/DkEAOIA0AAAAAAAAAAEACgAoUmVjb21tZW5kIGNvbnZlcnNpb24gLSB0aHJlc2hvbGQgcmVhY2hlZEyJiwCL/wmBZAuL/wqBBQxBADmANQAAAAAAAAABAAoAKVJlY29tbWVuZCBjb252ZXJzaW9uIC0gY2xvc2UgdG8gdGhyZXNob2xkTImAMgAAAAAAAAAAAAoAJkhvbGQgWVQgdG9rZW5zIC0gdGhyZXNob2xkIG5vdCByZWFjaGVkTImKAwExACIrZUQSRCcMi/1nJw2L/mcnDov/Z4AaQ29udHJhY3QgYWRkcmVzc2VzIHVwZGF0ZWSwgCdDb250cmFjdCBhZGRyZXNzZXMgdXBkYXRlZCBzdWNjZXNzZnVsbHmJ","clear":"CoEBQw=="},"compilerInfo":{"compiler":"puya","compilerVersion":{"major":4,"minor":10,"patch":0}},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


/**
 * The argument types for the YtAutoConverter contract
 */
export type YtAutoConverterArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'initialize(byte[],byte[],byte[])string': {
      oracleAddress: Uint8Array
      tokenizationAddress: Uint8Array
      ammAddress: Uint8Array
    }
    'configure_conversion(uint64,uint64,uint64)string': {
      enabled: bigint | number
      thresholdPrice: bigint | number
      maturity: bigint | number
    }
    'deposit_yt_tokens(uint64)string': {
      amount: bigint | number
    }
    'execute_conversion(byte[],uint64,uint64)string': {
      user: Uint8Array
      minPtAmount: bigint | number
      deadline: bigint | number
    }
    'can_execute_conversion(byte[])uint64': {
      user: Uint8Array
    }
    'get_user_config()(uint64,uint64,uint64,uint64)': Record<string, never>
    'get_user_balances()(uint64,uint64)': Record<string, never>
    'get_conversion_info()(uint64,uint64,uint64)': Record<string, never>
    'calculate_conversion_output(uint64)(uint64,uint64)': {
      ytAmount: bigint | number
    }
    'add_maturity(uint64)string': {
      maturity: bigint | number
    }
    'remove_maturity()string': Record<string, never>
    'set_conversion_fee(uint64)string': {
      newFee: bigint | number
    }
    'pause_converter()string': Record<string, never>
    'unpause_converter()string': Record<string, never>
    'emergency_disable_conversion()string': Record<string, never>
    'withdraw_pt_tokens(uint64)string': {
      amount: bigint | number
    }
    'get_ai_recommendation(uint64,uint64)(uint64,string)': {
      ytAmount: bigint | number
      currentPrice: bigint | number
    }
    'update_addresses(byte[],byte[],byte[])string': {
      oracleAddress: Uint8Array
      tokenizationAddress: Uint8Array
      ammAddress: Uint8Array
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'initialize(byte[],byte[],byte[])string': [oracleAddress: Uint8Array, tokenizationAddress: Uint8Array, ammAddress: Uint8Array]
    'configure_conversion(uint64,uint64,uint64)string': [enabled: bigint | number, thresholdPrice: bigint | number, maturity: bigint | number]
    'deposit_yt_tokens(uint64)string': [amount: bigint | number]
    'execute_conversion(byte[],uint64,uint64)string': [user: Uint8Array, minPtAmount: bigint | number, deadline: bigint | number]
    'can_execute_conversion(byte[])uint64': [user: Uint8Array]
    'get_user_config()(uint64,uint64,uint64,uint64)': []
    'get_user_balances()(uint64,uint64)': []
    'get_conversion_info()(uint64,uint64,uint64)': []
    'calculate_conversion_output(uint64)(uint64,uint64)': [ytAmount: bigint | number]
    'add_maturity(uint64)string': [maturity: bigint | number]
    'remove_maturity()string': []
    'set_conversion_fee(uint64)string': [newFee: bigint | number]
    'pause_converter()string': []
    'unpause_converter()string': []
    'emergency_disable_conversion()string': []
    'withdraw_pt_tokens(uint64)string': [amount: bigint | number]
    'get_ai_recommendation(uint64,uint64)(uint64,string)': [ytAmount: bigint | number, currentPrice: bigint | number]
    'update_addresses(byte[],byte[],byte[])string': [oracleAddress: Uint8Array, tokenizationAddress: Uint8Array, ammAddress: Uint8Array]
  }
}

/**
 * The return type for each method
 */
export type YtAutoConverterReturns = {
  'initialize(byte[],byte[],byte[])string': string
  'configure_conversion(uint64,uint64,uint64)string': string
  'deposit_yt_tokens(uint64)string': string
  'execute_conversion(byte[],uint64,uint64)string': string
  'can_execute_conversion(byte[])uint64': bigint
  'get_user_config()(uint64,uint64,uint64,uint64)': [bigint, bigint, bigint, bigint]
  'get_user_balances()(uint64,uint64)': [bigint, bigint]
  'get_conversion_info()(uint64,uint64,uint64)': [bigint, bigint, bigint]
  'calculate_conversion_output(uint64)(uint64,uint64)': [bigint, bigint]
  'add_maturity(uint64)string': string
  'remove_maturity()string': string
  'set_conversion_fee(uint64)string': string
  'pause_converter()string': string
  'unpause_converter()string': string
  'emergency_disable_conversion()string': string
  'withdraw_pt_tokens(uint64)string': string
  'get_ai_recommendation(uint64,uint64)(uint64,string)': [bigint, string]
  'update_addresses(byte[],byte[],byte[])string': string
}

/**
 * Defines the types of available calls and state of the YtAutoConverter smart contract.
 */
export type YtAutoConverterTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'initialize(byte[],byte[],byte[])string' | 'initialize', {
      argsObj: YtAutoConverterArgs['obj']['initialize(byte[],byte[],byte[])string']
      argsTuple: YtAutoConverterArgs['tuple']['initialize(byte[],byte[],byte[])string']
      returns: YtAutoConverterReturns['initialize(byte[],byte[],byte[])string']
    }>
    & Record<'configure_conversion(uint64,uint64,uint64)string' | 'configure_conversion', {
      argsObj: YtAutoConverterArgs['obj']['configure_conversion(uint64,uint64,uint64)string']
      argsTuple: YtAutoConverterArgs['tuple']['configure_conversion(uint64,uint64,uint64)string']
      returns: YtAutoConverterReturns['configure_conversion(uint64,uint64,uint64)string']
    }>
    & Record<'deposit_yt_tokens(uint64)string' | 'deposit_yt_tokens', {
      argsObj: YtAutoConverterArgs['obj']['deposit_yt_tokens(uint64)string']
      argsTuple: YtAutoConverterArgs['tuple']['deposit_yt_tokens(uint64)string']
      returns: YtAutoConverterReturns['deposit_yt_tokens(uint64)string']
    }>
    & Record<'execute_conversion(byte[],uint64,uint64)string' | 'execute_conversion', {
      argsObj: YtAutoConverterArgs['obj']['execute_conversion(byte[],uint64,uint64)string']
      argsTuple: YtAutoConverterArgs['tuple']['execute_conversion(byte[],uint64,uint64)string']
      returns: YtAutoConverterReturns['execute_conversion(byte[],uint64,uint64)string']
    }>
    & Record<'can_execute_conversion(byte[])uint64' | 'can_execute_conversion', {
      argsObj: YtAutoConverterArgs['obj']['can_execute_conversion(byte[])uint64']
      argsTuple: YtAutoConverterArgs['tuple']['can_execute_conversion(byte[])uint64']
      returns: YtAutoConverterReturns['can_execute_conversion(byte[])uint64']
    }>
    & Record<'get_user_config()(uint64,uint64,uint64,uint64)' | 'get_user_config', {
      argsObj: YtAutoConverterArgs['obj']['get_user_config()(uint64,uint64,uint64,uint64)']
      argsTuple: YtAutoConverterArgs['tuple']['get_user_config()(uint64,uint64,uint64,uint64)']
      returns: YtAutoConverterReturns['get_user_config()(uint64,uint64,uint64,uint64)']
    }>
    & Record<'get_user_balances()(uint64,uint64)' | 'get_user_balances', {
      argsObj: YtAutoConverterArgs['obj']['get_user_balances()(uint64,uint64)']
      argsTuple: YtAutoConverterArgs['tuple']['get_user_balances()(uint64,uint64)']
      returns: YtAutoConverterReturns['get_user_balances()(uint64,uint64)']
    }>
    & Record<'get_conversion_info()(uint64,uint64,uint64)' | 'get_conversion_info', {
      argsObj: YtAutoConverterArgs['obj']['get_conversion_info()(uint64,uint64,uint64)']
      argsTuple: YtAutoConverterArgs['tuple']['get_conversion_info()(uint64,uint64,uint64)']
      returns: YtAutoConverterReturns['get_conversion_info()(uint64,uint64,uint64)']
    }>
    & Record<'calculate_conversion_output(uint64)(uint64,uint64)' | 'calculate_conversion_output', {
      argsObj: YtAutoConverterArgs['obj']['calculate_conversion_output(uint64)(uint64,uint64)']
      argsTuple: YtAutoConverterArgs['tuple']['calculate_conversion_output(uint64)(uint64,uint64)']
      returns: YtAutoConverterReturns['calculate_conversion_output(uint64)(uint64,uint64)']
    }>
    & Record<'add_maturity(uint64)string' | 'add_maturity', {
      argsObj: YtAutoConverterArgs['obj']['add_maturity(uint64)string']
      argsTuple: YtAutoConverterArgs['tuple']['add_maturity(uint64)string']
      returns: YtAutoConverterReturns['add_maturity(uint64)string']
    }>
    & Record<'remove_maturity()string' | 'remove_maturity', {
      argsObj: YtAutoConverterArgs['obj']['remove_maturity()string']
      argsTuple: YtAutoConverterArgs['tuple']['remove_maturity()string']
      returns: YtAutoConverterReturns['remove_maturity()string']
    }>
    & Record<'set_conversion_fee(uint64)string' | 'set_conversion_fee', {
      argsObj: YtAutoConverterArgs['obj']['set_conversion_fee(uint64)string']
      argsTuple: YtAutoConverterArgs['tuple']['set_conversion_fee(uint64)string']
      returns: YtAutoConverterReturns['set_conversion_fee(uint64)string']
    }>
    & Record<'pause_converter()string' | 'pause_converter', {
      argsObj: YtAutoConverterArgs['obj']['pause_converter()string']
      argsTuple: YtAutoConverterArgs['tuple']['pause_converter()string']
      returns: YtAutoConverterReturns['pause_converter()string']
    }>
    & Record<'unpause_converter()string' | 'unpause_converter', {
      argsObj: YtAutoConverterArgs['obj']['unpause_converter()string']
      argsTuple: YtAutoConverterArgs['tuple']['unpause_converter()string']
      returns: YtAutoConverterReturns['unpause_converter()string']
    }>
    & Record<'emergency_disable_conversion()string' | 'emergency_disable_conversion', {
      argsObj: YtAutoConverterArgs['obj']['emergency_disable_conversion()string']
      argsTuple: YtAutoConverterArgs['tuple']['emergency_disable_conversion()string']
      returns: YtAutoConverterReturns['emergency_disable_conversion()string']
    }>
    & Record<'withdraw_pt_tokens(uint64)string' | 'withdraw_pt_tokens', {
      argsObj: YtAutoConverterArgs['obj']['withdraw_pt_tokens(uint64)string']
      argsTuple: YtAutoConverterArgs['tuple']['withdraw_pt_tokens(uint64)string']
      returns: YtAutoConverterReturns['withdraw_pt_tokens(uint64)string']
    }>
    & Record<'get_ai_recommendation(uint64,uint64)(uint64,string)' | 'get_ai_recommendation', {
      argsObj: YtAutoConverterArgs['obj']['get_ai_recommendation(uint64,uint64)(uint64,string)']
      argsTuple: YtAutoConverterArgs['tuple']['get_ai_recommendation(uint64,uint64)(uint64,string)']
      returns: YtAutoConverterReturns['get_ai_recommendation(uint64,uint64)(uint64,string)']
    }>
    & Record<'update_addresses(byte[],byte[],byte[])string' | 'update_addresses', {
      argsObj: YtAutoConverterArgs['obj']['update_addresses(byte[],byte[],byte[])string']
      argsTuple: YtAutoConverterArgs['tuple']['update_addresses(byte[],byte[],byte[])string']
      returns: YtAutoConverterReturns['update_addresses(byte[],byte[],byte[])string']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        admin: BinaryState
        oracleAddress: BinaryState
        tokenizationAddress: BinaryState
        ammAddress: BinaryState
        conversionFee: bigint
        isPaused: bigint
        totalConversions: bigint
        maxSlippage: bigint
        feeDenominator: bigint
      }
      maps: {}
    }
    local: {
      keys: {
        conversionEnabled: bigint
        thresholdPrice: bigint
        userMaturity: bigint
        conversionExecuted: bigint
        ytBalance: bigint
        ptBalance: bigint
      }
      maps: {}
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type YtAutoConverterSignatures = keyof YtAutoConverterTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type YtAutoConverterNonVoidMethodSignatures = keyof YtAutoConverterTypes['methods'] extends infer T ? T extends keyof YtAutoConverterTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the YtAutoConverter smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends YtAutoConverterSignatures> = YtAutoConverterTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the YtAutoConverter smart contract to the method's return type
 */
export type MethodReturn<TSignature extends YtAutoConverterSignatures> = YtAutoConverterTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = YtAutoConverterTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed local state of the application.
 */
export type LocalKeysState = YtAutoConverterTypes['state']['local']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type YtAutoConverterCreateCallParams =
  | Expand<AppClientBareCallParams & {method?: never} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines arguments required for the deploy method.
 */
export type YtAutoConverterDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: YtAutoConverterCreateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the YtAutoConverter smart contract
 */
export abstract class YtAutoConverterParamsFactory {
  /**
   * Constructs a no op call for the initialize(byte[],byte[],byte[])string ABI method
   *
   * Initialize the auto converter
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initialize(params: CallParams<YtAutoConverterArgs['obj']['initialize(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['initialize(byte[],byte[],byte[])string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'initialize(byte[],byte[],byte[])string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.oracleAddress, params.args.tokenizationAddress, params.args.ammAddress],
    }
  }
  /**
   * Constructs a no op call for the configure_conversion(uint64,uint64,uint64)string ABI method
   *
   * Configure automatic conversion for user
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static configureConversion(params: CallParams<YtAutoConverterArgs['obj']['configure_conversion(uint64,uint64,uint64)string'] | YtAutoConverterArgs['tuple']['configure_conversion(uint64,uint64,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'configure_conversion(uint64,uint64,uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.enabled, params.args.thresholdPrice, params.args.maturity],
    }
  }
  /**
   * Constructs a no op call for the deposit_yt_tokens(uint64)string ABI method
   *
   * Deposit YT tokens for conversion (for testing)
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static depositYtTokens(params: CallParams<YtAutoConverterArgs['obj']['deposit_yt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['deposit_yt_tokens(uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'deposit_yt_tokens(uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.amount],
    }
  }
  /**
   * Constructs a no op call for the execute_conversion(byte[],uint64,uint64)string ABI method
   *
   * Execute YT to PT conversion
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static executeConversion(params: CallParams<YtAutoConverterArgs['obj']['execute_conversion(byte[],uint64,uint64)string'] | YtAutoConverterArgs['tuple']['execute_conversion(byte[],uint64,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'execute_conversion(byte[],uint64,uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.user, params.args.minPtAmount, params.args.deadline],
    }
  }
  /**
   * Constructs a no op call for the can_execute_conversion(byte[])uint64 ABI method
   *
   * Check if conversion can be executed for user
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static canExecuteConversion(params: CallParams<YtAutoConverterArgs['obj']['can_execute_conversion(byte[])uint64'] | YtAutoConverterArgs['tuple']['can_execute_conversion(byte[])uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'can_execute_conversion(byte[])uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.user],
    }
  }
  /**
   * Constructs a no op call for the get_user_config()(uint64,uint64,uint64,uint64) ABI method
   *
   * Get user's conversion configuration
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getUserConfig(params: CallParams<YtAutoConverterArgs['obj']['get_user_config()(uint64,uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_config()(uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_user_config()(uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the get_user_balances()(uint64,uint64) ABI method
   *
   * Get user's YT and PT balances
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getUserBalances(params: CallParams<YtAutoConverterArgs['obj']['get_user_balances()(uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_balances()(uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_user_balances()(uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the get_conversion_info()(uint64,uint64,uint64) ABI method
   *
   * Get conversion information
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getConversionInfo(params: CallParams<YtAutoConverterArgs['obj']['get_conversion_info()(uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_conversion_info()(uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_conversion_info()(uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the calculate_conversion_output(uint64)(uint64,uint64) ABI method
   *
   * Calculate expected PT output for YT input
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static calculateConversionOutput(params: CallParams<YtAutoConverterArgs['obj']['calculate_conversion_output(uint64)(uint64,uint64)'] | YtAutoConverterArgs['tuple']['calculate_conversion_output(uint64)(uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'calculate_conversion_output(uint64)(uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.ytAmount],
    }
  }
  /**
   * Constructs a no op call for the add_maturity(uint64)string ABI method
   *
   * Add a maturity for conversion
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addMaturity(params: CallParams<YtAutoConverterArgs['obj']['add_maturity(uint64)string'] | YtAutoConverterArgs['tuple']['add_maturity(uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'add_maturity(uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.maturity],
    }
  }
  /**
   * Constructs a no op call for the remove_maturity()string ABI method
   *
   * Remove user's maturity
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static removeMaturity(params: CallParams<YtAutoConverterArgs['obj']['remove_maturity()string'] | YtAutoConverterArgs['tuple']['remove_maturity()string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'remove_maturity()string' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the set_conversion_fee(uint64)string ABI method
   *
   * Set conversion fee (admin only)
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setConversionFee(params: CallParams<YtAutoConverterArgs['obj']['set_conversion_fee(uint64)string'] | YtAutoConverterArgs['tuple']['set_conversion_fee(uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'set_conversion_fee(uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newFee],
    }
  }
  /**
   * Constructs a no op call for the pause_converter()string ABI method
   *
   * Pause the converter (admin only)
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static pauseConverter(params: CallParams<YtAutoConverterArgs['obj']['pause_converter()string'] | YtAutoConverterArgs['tuple']['pause_converter()string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'pause_converter()string' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the unpause_converter()string ABI method
   *
   * Unpause the converter (admin only)
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static unpauseConverter(params: CallParams<YtAutoConverterArgs['obj']['unpause_converter()string'] | YtAutoConverterArgs['tuple']['unpause_converter()string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'unpause_converter()string' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the emergency_disable_conversion()string ABI method
   *
   * Emergency disable conversion for user
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static emergencyDisableConversion(params: CallParams<YtAutoConverterArgs['obj']['emergency_disable_conversion()string'] | YtAutoConverterArgs['tuple']['emergency_disable_conversion()string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'emergency_disable_conversion()string' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the withdraw_pt_tokens(uint64)string ABI method
   *
   * Withdraw PT tokens
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static withdrawPtTokens(params: CallParams<YtAutoConverterArgs['obj']['withdraw_pt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['withdraw_pt_tokens(uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'withdraw_pt_tokens(uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.amount],
    }
  }
  /**
   * Constructs a no op call for the get_ai_recommendation(uint64,uint64)(uint64,string) ABI method
   *
   * Get AI recommendation for conversion (simplified)
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getAiRecommendation(params: CallParams<YtAutoConverterArgs['obj']['get_ai_recommendation(uint64,uint64)(uint64,string)'] | YtAutoConverterArgs['tuple']['get_ai_recommendation(uint64,uint64)(uint64,string)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_ai_recommendation(uint64,uint64)(uint64,string)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.ytAmount, params.args.currentPrice],
    }
  }
  /**
   * Constructs a no op call for the update_addresses(byte[],byte[],byte[])string ABI method
   *
   * Update contract addresses (admin only)
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAddresses(params: CallParams<YtAutoConverterArgs['obj']['update_addresses(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['update_addresses(byte[],byte[],byte[])string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'update_addresses(byte[],byte[],byte[])string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.oracleAddress, params.args.tokenizationAddress, params.args.ammAddress],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the YTAutoConverter smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class YtAutoConverterFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `YtAutoConverterFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new YtAutoConverterClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new YtAutoConverterClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the YTAutoConverter smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: YtAutoConverterDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
    })
    return { result: result.result, appClient: new YtAutoConverterClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the YTAutoConverter smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.params.bare.create(params)
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the YTAutoConverter smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.createTransaction.bare.create(params)
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the YTAutoConverter smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        const result = await this.appFactory.send.bare.create(params)
        return { result: result.result, appClient: new YtAutoConverterClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the YTAutoConverter smart contract
 */
export class YtAutoConverterClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `YtAutoConverterClient`
   *
   * @param appClient An `AppClient` instance which has been created with the YtAutoConverter app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `YtAutoConverterClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends YtAutoConverterNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `YtAutoConverterClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<YtAutoConverterClient> {
    return new YtAutoConverterClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `YtAutoConverterClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<YtAutoConverterClient> {
    return new YtAutoConverterClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Makes a clear_state call to an existing instance of the YTAutoConverter smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `initialize(byte[],byte[],byte[])string` ABI method.
     *
     * Initialize the auto converter
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initialize: (params: CallParams<YtAutoConverterArgs['obj']['initialize(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['initialize(byte[],byte[],byte[])string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.initialize(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `configure_conversion(uint64,uint64,uint64)string` ABI method.
     *
     * Configure automatic conversion for user
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    configureConversion: (params: CallParams<YtAutoConverterArgs['obj']['configure_conversion(uint64,uint64,uint64)string'] | YtAutoConverterArgs['tuple']['configure_conversion(uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.configureConversion(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `deposit_yt_tokens(uint64)string` ABI method.
     *
     * Deposit YT tokens for conversion (for testing)
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    depositYtTokens: (params: CallParams<YtAutoConverterArgs['obj']['deposit_yt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['deposit_yt_tokens(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.depositYtTokens(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `execute_conversion(byte[],uint64,uint64)string` ABI method.
     *
     * Execute YT to PT conversion
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    executeConversion: (params: CallParams<YtAutoConverterArgs['obj']['execute_conversion(byte[],uint64,uint64)string'] | YtAutoConverterArgs['tuple']['execute_conversion(byte[],uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.executeConversion(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `can_execute_conversion(byte[])uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Check if conversion can be executed for user
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    canExecuteConversion: (params: CallParams<YtAutoConverterArgs['obj']['can_execute_conversion(byte[])uint64'] | YtAutoConverterArgs['tuple']['can_execute_conversion(byte[])uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.canExecuteConversion(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_user_config()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get user's conversion configuration
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getUserConfig: (params: CallParams<YtAutoConverterArgs['obj']['get_user_config()(uint64,uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_config()(uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.getUserConfig(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_user_balances()(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get user's YT and PT balances
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getUserBalances: (params: CallParams<YtAutoConverterArgs['obj']['get_user_balances()(uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_balances()(uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.getUserBalances(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_conversion_info()(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get conversion information
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getConversionInfo: (params: CallParams<YtAutoConverterArgs['obj']['get_conversion_info()(uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_conversion_info()(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.getConversionInfo(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `calculate_conversion_output(uint64)(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculate expected PT output for YT input
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    calculateConversionOutput: (params: CallParams<YtAutoConverterArgs['obj']['calculate_conversion_output(uint64)(uint64,uint64)'] | YtAutoConverterArgs['tuple']['calculate_conversion_output(uint64)(uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.calculateConversionOutput(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `add_maturity(uint64)string` ABI method.
     *
     * Add a maturity for conversion
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addMaturity: (params: CallParams<YtAutoConverterArgs['obj']['add_maturity(uint64)string'] | YtAutoConverterArgs['tuple']['add_maturity(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.addMaturity(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `remove_maturity()string` ABI method.
     *
     * Remove user's maturity
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    removeMaturity: (params: CallParams<YtAutoConverterArgs['obj']['remove_maturity()string'] | YtAutoConverterArgs['tuple']['remove_maturity()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.removeMaturity(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `set_conversion_fee(uint64)string` ABI method.
     *
     * Set conversion fee (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setConversionFee: (params: CallParams<YtAutoConverterArgs['obj']['set_conversion_fee(uint64)string'] | YtAutoConverterArgs['tuple']['set_conversion_fee(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.setConversionFee(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `pause_converter()string` ABI method.
     *
     * Pause the converter (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    pauseConverter: (params: CallParams<YtAutoConverterArgs['obj']['pause_converter()string'] | YtAutoConverterArgs['tuple']['pause_converter()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.pauseConverter(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `unpause_converter()string` ABI method.
     *
     * Unpause the converter (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    unpauseConverter: (params: CallParams<YtAutoConverterArgs['obj']['unpause_converter()string'] | YtAutoConverterArgs['tuple']['unpause_converter()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.unpauseConverter(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `emergency_disable_conversion()string` ABI method.
     *
     * Emergency disable conversion for user
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    emergencyDisableConversion: (params: CallParams<YtAutoConverterArgs['obj']['emergency_disable_conversion()string'] | YtAutoConverterArgs['tuple']['emergency_disable_conversion()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.emergencyDisableConversion(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `withdraw_pt_tokens(uint64)string` ABI method.
     *
     * Withdraw PT tokens
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    withdrawPtTokens: (params: CallParams<YtAutoConverterArgs['obj']['withdraw_pt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['withdraw_pt_tokens(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.withdrawPtTokens(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_ai_recommendation(uint64,uint64)(uint64,string)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get AI recommendation for conversion (simplified)
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getAiRecommendation: (params: CallParams<YtAutoConverterArgs['obj']['get_ai_recommendation(uint64,uint64)(uint64,string)'] | YtAutoConverterArgs['tuple']['get_ai_recommendation(uint64,uint64)(uint64,string)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.getAiRecommendation(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `update_addresses(byte[],byte[],byte[])string` ABI method.
     *
     * Update contract addresses (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAddresses: (params: CallParams<YtAutoConverterArgs['obj']['update_addresses(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['update_addresses(byte[],byte[],byte[])string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(YtAutoConverterParamsFactory.updateAddresses(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the YTAutoConverter smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `initialize(byte[],byte[],byte[])string` ABI method.
     *
     * Initialize the auto converter
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initialize: (params: CallParams<YtAutoConverterArgs['obj']['initialize(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['initialize(byte[],byte[],byte[])string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.initialize(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `configure_conversion(uint64,uint64,uint64)string` ABI method.
     *
     * Configure automatic conversion for user
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    configureConversion: (params: CallParams<YtAutoConverterArgs['obj']['configure_conversion(uint64,uint64,uint64)string'] | YtAutoConverterArgs['tuple']['configure_conversion(uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.configureConversion(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `deposit_yt_tokens(uint64)string` ABI method.
     *
     * Deposit YT tokens for conversion (for testing)
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    depositYtTokens: (params: CallParams<YtAutoConverterArgs['obj']['deposit_yt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['deposit_yt_tokens(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.depositYtTokens(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `execute_conversion(byte[],uint64,uint64)string` ABI method.
     *
     * Execute YT to PT conversion
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    executeConversion: (params: CallParams<YtAutoConverterArgs['obj']['execute_conversion(byte[],uint64,uint64)string'] | YtAutoConverterArgs['tuple']['execute_conversion(byte[],uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.executeConversion(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `can_execute_conversion(byte[])uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Check if conversion can be executed for user
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    canExecuteConversion: (params: CallParams<YtAutoConverterArgs['obj']['can_execute_conversion(byte[])uint64'] | YtAutoConverterArgs['tuple']['can_execute_conversion(byte[])uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.canExecuteConversion(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_user_config()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get user's conversion configuration
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getUserConfig: (params: CallParams<YtAutoConverterArgs['obj']['get_user_config()(uint64,uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_config()(uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.getUserConfig(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_user_balances()(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get user's YT and PT balances
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getUserBalances: (params: CallParams<YtAutoConverterArgs['obj']['get_user_balances()(uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_balances()(uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.getUserBalances(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_conversion_info()(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get conversion information
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getConversionInfo: (params: CallParams<YtAutoConverterArgs['obj']['get_conversion_info()(uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_conversion_info()(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.getConversionInfo(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `calculate_conversion_output(uint64)(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculate expected PT output for YT input
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    calculateConversionOutput: (params: CallParams<YtAutoConverterArgs['obj']['calculate_conversion_output(uint64)(uint64,uint64)'] | YtAutoConverterArgs['tuple']['calculate_conversion_output(uint64)(uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.calculateConversionOutput(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `add_maturity(uint64)string` ABI method.
     *
     * Add a maturity for conversion
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addMaturity: (params: CallParams<YtAutoConverterArgs['obj']['add_maturity(uint64)string'] | YtAutoConverterArgs['tuple']['add_maturity(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.addMaturity(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `remove_maturity()string` ABI method.
     *
     * Remove user's maturity
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    removeMaturity: (params: CallParams<YtAutoConverterArgs['obj']['remove_maturity()string'] | YtAutoConverterArgs['tuple']['remove_maturity()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.removeMaturity(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `set_conversion_fee(uint64)string` ABI method.
     *
     * Set conversion fee (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setConversionFee: (params: CallParams<YtAutoConverterArgs['obj']['set_conversion_fee(uint64)string'] | YtAutoConverterArgs['tuple']['set_conversion_fee(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.setConversionFee(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `pause_converter()string` ABI method.
     *
     * Pause the converter (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    pauseConverter: (params: CallParams<YtAutoConverterArgs['obj']['pause_converter()string'] | YtAutoConverterArgs['tuple']['pause_converter()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.pauseConverter(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `unpause_converter()string` ABI method.
     *
     * Unpause the converter (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    unpauseConverter: (params: CallParams<YtAutoConverterArgs['obj']['unpause_converter()string'] | YtAutoConverterArgs['tuple']['unpause_converter()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.unpauseConverter(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `emergency_disable_conversion()string` ABI method.
     *
     * Emergency disable conversion for user
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    emergencyDisableConversion: (params: CallParams<YtAutoConverterArgs['obj']['emergency_disable_conversion()string'] | YtAutoConverterArgs['tuple']['emergency_disable_conversion()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.emergencyDisableConversion(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `withdraw_pt_tokens(uint64)string` ABI method.
     *
     * Withdraw PT tokens
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    withdrawPtTokens: (params: CallParams<YtAutoConverterArgs['obj']['withdraw_pt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['withdraw_pt_tokens(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.withdrawPtTokens(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_ai_recommendation(uint64,uint64)(uint64,string)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get AI recommendation for conversion (simplified)
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getAiRecommendation: (params: CallParams<YtAutoConverterArgs['obj']['get_ai_recommendation(uint64,uint64)(uint64,string)'] | YtAutoConverterArgs['tuple']['get_ai_recommendation(uint64,uint64)(uint64,string)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.getAiRecommendation(params))
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `update_addresses(byte[],byte[],byte[])string` ABI method.
     *
     * Update contract addresses (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAddresses: (params: CallParams<YtAutoConverterArgs['obj']['update_addresses(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['update_addresses(byte[],byte[],byte[])string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(YtAutoConverterParamsFactory.updateAddresses(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Makes a clear_state call to an existing instance of the YTAutoConverter smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `initialize(byte[],byte[],byte[])string` ABI method.
     *
     * Initialize the auto converter
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initialize: async (params: CallParams<YtAutoConverterArgs['obj']['initialize(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['initialize(byte[],byte[],byte[])string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.initialize(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['initialize(byte[],byte[],byte[])string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `configure_conversion(uint64,uint64,uint64)string` ABI method.
     *
     * Configure automatic conversion for user
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    configureConversion: async (params: CallParams<YtAutoConverterArgs['obj']['configure_conversion(uint64,uint64,uint64)string'] | YtAutoConverterArgs['tuple']['configure_conversion(uint64,uint64,uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.configureConversion(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['configure_conversion(uint64,uint64,uint64)string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `deposit_yt_tokens(uint64)string` ABI method.
     *
     * Deposit YT tokens for conversion (for testing)
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    depositYtTokens: async (params: CallParams<YtAutoConverterArgs['obj']['deposit_yt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['deposit_yt_tokens(uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.depositYtTokens(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['deposit_yt_tokens(uint64)string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `execute_conversion(byte[],uint64,uint64)string` ABI method.
     *
     * Execute YT to PT conversion
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    executeConversion: async (params: CallParams<YtAutoConverterArgs['obj']['execute_conversion(byte[],uint64,uint64)string'] | YtAutoConverterArgs['tuple']['execute_conversion(byte[],uint64,uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.executeConversion(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['execute_conversion(byte[],uint64,uint64)string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `can_execute_conversion(byte[])uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Check if conversion can be executed for user
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    canExecuteConversion: async (params: CallParams<YtAutoConverterArgs['obj']['can_execute_conversion(byte[])uint64'] | YtAutoConverterArgs['tuple']['can_execute_conversion(byte[])uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.canExecuteConversion(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['can_execute_conversion(byte[])uint64'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_user_config()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get user's conversion configuration
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getUserConfig: async (params: CallParams<YtAutoConverterArgs['obj']['get_user_config()(uint64,uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_config()(uint64,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.getUserConfig(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['get_user_config()(uint64,uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_user_balances()(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get user's YT and PT balances
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getUserBalances: async (params: CallParams<YtAutoConverterArgs['obj']['get_user_balances()(uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_balances()(uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.getUserBalances(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['get_user_balances()(uint64,uint64)'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_conversion_info()(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get conversion information
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getConversionInfo: async (params: CallParams<YtAutoConverterArgs['obj']['get_conversion_info()(uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_conversion_info()(uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.getConversionInfo(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['get_conversion_info()(uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `calculate_conversion_output(uint64)(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculate expected PT output for YT input
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    calculateConversionOutput: async (params: CallParams<YtAutoConverterArgs['obj']['calculate_conversion_output(uint64)(uint64,uint64)'] | YtAutoConverterArgs['tuple']['calculate_conversion_output(uint64)(uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.calculateConversionOutput(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['calculate_conversion_output(uint64)(uint64,uint64)'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `add_maturity(uint64)string` ABI method.
     *
     * Add a maturity for conversion
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addMaturity: async (params: CallParams<YtAutoConverterArgs['obj']['add_maturity(uint64)string'] | YtAutoConverterArgs['tuple']['add_maturity(uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.addMaturity(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['add_maturity(uint64)string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `remove_maturity()string` ABI method.
     *
     * Remove user's maturity
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    removeMaturity: async (params: CallParams<YtAutoConverterArgs['obj']['remove_maturity()string'] | YtAutoConverterArgs['tuple']['remove_maturity()string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.removeMaturity(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['remove_maturity()string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `set_conversion_fee(uint64)string` ABI method.
     *
     * Set conversion fee (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setConversionFee: async (params: CallParams<YtAutoConverterArgs['obj']['set_conversion_fee(uint64)string'] | YtAutoConverterArgs['tuple']['set_conversion_fee(uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.setConversionFee(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['set_conversion_fee(uint64)string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `pause_converter()string` ABI method.
     *
     * Pause the converter (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    pauseConverter: async (params: CallParams<YtAutoConverterArgs['obj']['pause_converter()string'] | YtAutoConverterArgs['tuple']['pause_converter()string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.pauseConverter(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['pause_converter()string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `unpause_converter()string` ABI method.
     *
     * Unpause the converter (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    unpauseConverter: async (params: CallParams<YtAutoConverterArgs['obj']['unpause_converter()string'] | YtAutoConverterArgs['tuple']['unpause_converter()string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.unpauseConverter(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['unpause_converter()string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `emergency_disable_conversion()string` ABI method.
     *
     * Emergency disable conversion for user
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    emergencyDisableConversion: async (params: CallParams<YtAutoConverterArgs['obj']['emergency_disable_conversion()string'] | YtAutoConverterArgs['tuple']['emergency_disable_conversion()string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.emergencyDisableConversion(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['emergency_disable_conversion()string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `withdraw_pt_tokens(uint64)string` ABI method.
     *
     * Withdraw PT tokens
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    withdrawPtTokens: async (params: CallParams<YtAutoConverterArgs['obj']['withdraw_pt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['withdraw_pt_tokens(uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.withdrawPtTokens(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['withdraw_pt_tokens(uint64)string'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `get_ai_recommendation(uint64,uint64)(uint64,string)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get AI recommendation for conversion (simplified)
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getAiRecommendation: async (params: CallParams<YtAutoConverterArgs['obj']['get_ai_recommendation(uint64,uint64)(uint64,string)'] | YtAutoConverterArgs['tuple']['get_ai_recommendation(uint64,uint64)(uint64,string)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.getAiRecommendation(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['get_ai_recommendation(uint64,uint64)(uint64,string)'])}
    },

    /**
     * Makes a call to the YTAutoConverter smart contract using the `update_addresses(byte[],byte[],byte[])string` ABI method.
     *
     * Update contract addresses (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAddresses: async (params: CallParams<YtAutoConverterArgs['obj']['update_addresses(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['update_addresses(byte[],byte[],byte[])string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(YtAutoConverterParamsFactory.updateAddresses(params))
      return {...result, return: result.return as unknown as (undefined | YtAutoConverterReturns['update_addresses(byte[],byte[],byte[])string'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new YtAutoConverterClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the YTAutoConverter smart contract using the `can_execute_conversion(byte[])uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Check if conversion can be executed for user
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async canExecuteConversion(params: CallParams<YtAutoConverterArgs['obj']['can_execute_conversion(byte[])uint64'] | YtAutoConverterArgs['tuple']['can_execute_conversion(byte[])uint64']>) {
    const result = await this.appClient.send.call(YtAutoConverterParamsFactory.canExecuteConversion(params))
    return result.return as unknown as YtAutoConverterReturns['can_execute_conversion(byte[])uint64']
  }

  /**
   * Makes a readonly (simulated) call to the YTAutoConverter smart contract using the `get_user_config()(uint64,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get user's conversion configuration
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getUserConfig(params: CallParams<YtAutoConverterArgs['obj']['get_user_config()(uint64,uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_config()(uint64,uint64,uint64,uint64)']> = {args: []}) {
    const result = await this.appClient.send.call(YtAutoConverterParamsFactory.getUserConfig(params))
    return result.return as unknown as YtAutoConverterReturns['get_user_config()(uint64,uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the YTAutoConverter smart contract using the `get_user_balances()(uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get user's YT and PT balances
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getUserBalances(params: CallParams<YtAutoConverterArgs['obj']['get_user_balances()(uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_balances()(uint64,uint64)']> = {args: []}) {
    const result = await this.appClient.send.call(YtAutoConverterParamsFactory.getUserBalances(params))
    return result.return as unknown as YtAutoConverterReturns['get_user_balances()(uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the YTAutoConverter smart contract using the `get_conversion_info()(uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get conversion information
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getConversionInfo(params: CallParams<YtAutoConverterArgs['obj']['get_conversion_info()(uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_conversion_info()(uint64,uint64,uint64)']> = {args: []}) {
    const result = await this.appClient.send.call(YtAutoConverterParamsFactory.getConversionInfo(params))
    return result.return as unknown as YtAutoConverterReturns['get_conversion_info()(uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the YTAutoConverter smart contract using the `calculate_conversion_output(uint64)(uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Calculate expected PT output for YT input
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async calculateConversionOutput(params: CallParams<YtAutoConverterArgs['obj']['calculate_conversion_output(uint64)(uint64,uint64)'] | YtAutoConverterArgs['tuple']['calculate_conversion_output(uint64)(uint64,uint64)']>) {
    const result = await this.appClient.send.call(YtAutoConverterParamsFactory.calculateConversionOutput(params))
    return result.return as unknown as YtAutoConverterReturns['calculate_conversion_output(uint64)(uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the YTAutoConverter smart contract using the `get_ai_recommendation(uint64,uint64)(uint64,string)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get AI recommendation for conversion (simplified)
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getAiRecommendation(params: CallParams<YtAutoConverterArgs['obj']['get_ai_recommendation(uint64,uint64)(uint64,string)'] | YtAutoConverterArgs['tuple']['get_ai_recommendation(uint64,uint64)(uint64,string)']>) {
    const result = await this.appClient.send.call(YtAutoConverterParamsFactory.getAiRecommendation(params))
    return result.return as unknown as YtAutoConverterReturns['get_ai_recommendation(uint64,uint64)(uint64,string)']
  }

  /**
   * Methods to access state for the current YTAutoConverter app
   */
  state = {
    /**
     * Methods to access global state for the current YTAutoConverter app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          admin: new BinaryStateValue(result.admin),
          oracleAddress: new BinaryStateValue(result.oracle_address),
          tokenizationAddress: new BinaryStateValue(result.tokenization_address),
          ammAddress: new BinaryStateValue(result.amm_address),
          conversionFee: result.conversion_fee,
          isPaused: result.is_paused,
          totalConversions: result.total_conversions,
          maxSlippage: result.max_slippage,
          feeDenominator: result.fee_denominator,
        }
      },
      /**
       * Get the current value of the admin key in global state
       */
      admin: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("admin")) as Uint8Array | undefined) },
      /**
       * Get the current value of the oracle_address key in global state
       */
      oracleAddress: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("oracle_address")) as Uint8Array | undefined) },
      /**
       * Get the current value of the tokenization_address key in global state
       */
      tokenizationAddress: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("tokenization_address")) as Uint8Array | undefined) },
      /**
       * Get the current value of the amm_address key in global state
       */
      ammAddress: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("amm_address")) as Uint8Array | undefined) },
      /**
       * Get the current value of the conversion_fee key in global state
       */
      conversionFee: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("conversion_fee")) as bigint | undefined },
      /**
       * Get the current value of the is_paused key in global state
       */
      isPaused: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("is_paused")) as bigint | undefined },
      /**
       * Get the current value of the total_conversions key in global state
       */
      totalConversions: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("total_conversions")) as bigint | undefined },
      /**
       * Get the current value of the max_slippage key in global state
       */
      maxSlippage: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("max_slippage")) as bigint | undefined },
      /**
       * Get the current value of the fee_denominator key in global state
       */
      feeDenominator: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("fee_denominator")) as bigint | undefined },
    },
    /**
     * Methods to access local state for the current YTAutoConverter app
     */
    local: (address: string | Address) => {
      const encodedAddress = typeof address === 'string' ? address : encodeAddress(address.publicKey)
      return {
        /**
         * Get all current keyed values from local state
         */
        getAll: async (): Promise<Partial<Expand<LocalKeysState>>> => {
          const result = await this.appClient.state.local(encodedAddress).getAll()
          return {
            conversionEnabled: result.conversion_enabled,
            thresholdPrice: result.threshold_price,
            userMaturity: result.user_maturity,
            conversionExecuted: result.conversion_executed,
            ytBalance: result.yt_balance,
            ptBalance: result.pt_balance,
          }
        },
        /**
         * Get the current value of the conversion_enabled key in local state
         */
        conversionEnabled: async (): Promise<bigint | undefined> => { return (await this.appClient.state.local(encodedAddress).getValue("conversion_enabled")) as bigint | undefined },
        /**
         * Get the current value of the threshold_price key in local state
         */
        thresholdPrice: async (): Promise<bigint | undefined> => { return (await this.appClient.state.local(encodedAddress).getValue("threshold_price")) as bigint | undefined },
        /**
         * Get the current value of the user_maturity key in local state
         */
        userMaturity: async (): Promise<bigint | undefined> => { return (await this.appClient.state.local(encodedAddress).getValue("user_maturity")) as bigint | undefined },
        /**
         * Get the current value of the conversion_executed key in local state
         */
        conversionExecuted: async (): Promise<bigint | undefined> => { return (await this.appClient.state.local(encodedAddress).getValue("conversion_executed")) as bigint | undefined },
        /**
         * Get the current value of the yt_balance key in local state
         */
        ytBalance: async (): Promise<bigint | undefined> => { return (await this.appClient.state.local(encodedAddress).getValue("yt_balance")) as bigint | undefined },
        /**
         * Get the current value of the pt_balance key in local state
         */
        ptBalance: async (): Promise<bigint | undefined> => { return (await this.appClient.state.local(encodedAddress).getValue("pt_balance")) as bigint | undefined },
      }
    },
  }

  public newGroup(): YtAutoConverterComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a initialize(byte[],byte[],byte[])string method call against the YTAutoConverter contract
       */
      initialize(params: CallParams<YtAutoConverterArgs['obj']['initialize(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['initialize(byte[],byte[],byte[])string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initialize(params)))
        resultMappers.push((v) => client.decodeReturnValue('initialize(byte[],byte[],byte[])string', v))
        return this
      },
      /**
       * Add a configure_conversion(uint64,uint64,uint64)string method call against the YTAutoConverter contract
       */
      configureConversion(params: CallParams<YtAutoConverterArgs['obj']['configure_conversion(uint64,uint64,uint64)string'] | YtAutoConverterArgs['tuple']['configure_conversion(uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.configureConversion(params)))
        resultMappers.push((v) => client.decodeReturnValue('configure_conversion(uint64,uint64,uint64)string', v))
        return this
      },
      /**
       * Add a deposit_yt_tokens(uint64)string method call against the YTAutoConverter contract
       */
      depositYtTokens(params: CallParams<YtAutoConverterArgs['obj']['deposit_yt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['deposit_yt_tokens(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.depositYtTokens(params)))
        resultMappers.push((v) => client.decodeReturnValue('deposit_yt_tokens(uint64)string', v))
        return this
      },
      /**
       * Add a execute_conversion(byte[],uint64,uint64)string method call against the YTAutoConverter contract
       */
      executeConversion(params: CallParams<YtAutoConverterArgs['obj']['execute_conversion(byte[],uint64,uint64)string'] | YtAutoConverterArgs['tuple']['execute_conversion(byte[],uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.executeConversion(params)))
        resultMappers.push((v) => client.decodeReturnValue('execute_conversion(byte[],uint64,uint64)string', v))
        return this
      },
      /**
       * Add a can_execute_conversion(byte[])uint64 method call against the YTAutoConverter contract
       */
      canExecuteConversion(params: CallParams<YtAutoConverterArgs['obj']['can_execute_conversion(byte[])uint64'] | YtAutoConverterArgs['tuple']['can_execute_conversion(byte[])uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.canExecuteConversion(params)))
        resultMappers.push((v) => client.decodeReturnValue('can_execute_conversion(byte[])uint64', v))
        return this
      },
      /**
       * Add a get_user_config()(uint64,uint64,uint64,uint64) method call against the YTAutoConverter contract
       */
      getUserConfig(params: CallParams<YtAutoConverterArgs['obj']['get_user_config()(uint64,uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_config()(uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getUserConfig(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_user_config()(uint64,uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a get_user_balances()(uint64,uint64) method call against the YTAutoConverter contract
       */
      getUserBalances(params: CallParams<YtAutoConverterArgs['obj']['get_user_balances()(uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_balances()(uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getUserBalances(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_user_balances()(uint64,uint64)', v))
        return this
      },
      /**
       * Add a get_conversion_info()(uint64,uint64,uint64) method call against the YTAutoConverter contract
       */
      getConversionInfo(params: CallParams<YtAutoConverterArgs['obj']['get_conversion_info()(uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_conversion_info()(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getConversionInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_conversion_info()(uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a calculate_conversion_output(uint64)(uint64,uint64) method call against the YTAutoConverter contract
       */
      calculateConversionOutput(params: CallParams<YtAutoConverterArgs['obj']['calculate_conversion_output(uint64)(uint64,uint64)'] | YtAutoConverterArgs['tuple']['calculate_conversion_output(uint64)(uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.calculateConversionOutput(params)))
        resultMappers.push((v) => client.decodeReturnValue('calculate_conversion_output(uint64)(uint64,uint64)', v))
        return this
      },
      /**
       * Add a add_maturity(uint64)string method call against the YTAutoConverter contract
       */
      addMaturity(params: CallParams<YtAutoConverterArgs['obj']['add_maturity(uint64)string'] | YtAutoConverterArgs['tuple']['add_maturity(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addMaturity(params)))
        resultMappers.push((v) => client.decodeReturnValue('add_maturity(uint64)string', v))
        return this
      },
      /**
       * Add a remove_maturity()string method call against the YTAutoConverter contract
       */
      removeMaturity(params: CallParams<YtAutoConverterArgs['obj']['remove_maturity()string'] | YtAutoConverterArgs['tuple']['remove_maturity()string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.removeMaturity(params)))
        resultMappers.push((v) => client.decodeReturnValue('remove_maturity()string', v))
        return this
      },
      /**
       * Add a set_conversion_fee(uint64)string method call against the YTAutoConverter contract
       */
      setConversionFee(params: CallParams<YtAutoConverterArgs['obj']['set_conversion_fee(uint64)string'] | YtAutoConverterArgs['tuple']['set_conversion_fee(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setConversionFee(params)))
        resultMappers.push((v) => client.decodeReturnValue('set_conversion_fee(uint64)string', v))
        return this
      },
      /**
       * Add a pause_converter()string method call against the YTAutoConverter contract
       */
      pauseConverter(params: CallParams<YtAutoConverterArgs['obj']['pause_converter()string'] | YtAutoConverterArgs['tuple']['pause_converter()string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.pauseConverter(params)))
        resultMappers.push((v) => client.decodeReturnValue('pause_converter()string', v))
        return this
      },
      /**
       * Add a unpause_converter()string method call against the YTAutoConverter contract
       */
      unpauseConverter(params: CallParams<YtAutoConverterArgs['obj']['unpause_converter()string'] | YtAutoConverterArgs['tuple']['unpause_converter()string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.unpauseConverter(params)))
        resultMappers.push((v) => client.decodeReturnValue('unpause_converter()string', v))
        return this
      },
      /**
       * Add a emergency_disable_conversion()string method call against the YTAutoConverter contract
       */
      emergencyDisableConversion(params: CallParams<YtAutoConverterArgs['obj']['emergency_disable_conversion()string'] | YtAutoConverterArgs['tuple']['emergency_disable_conversion()string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.emergencyDisableConversion(params)))
        resultMappers.push((v) => client.decodeReturnValue('emergency_disable_conversion()string', v))
        return this
      },
      /**
       * Add a withdraw_pt_tokens(uint64)string method call against the YTAutoConverter contract
       */
      withdrawPtTokens(params: CallParams<YtAutoConverterArgs['obj']['withdraw_pt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['withdraw_pt_tokens(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.withdrawPtTokens(params)))
        resultMappers.push((v) => client.decodeReturnValue('withdraw_pt_tokens(uint64)string', v))
        return this
      },
      /**
       * Add a get_ai_recommendation(uint64,uint64)(uint64,string) method call against the YTAutoConverter contract
       */
      getAiRecommendation(params: CallParams<YtAutoConverterArgs['obj']['get_ai_recommendation(uint64,uint64)(uint64,string)'] | YtAutoConverterArgs['tuple']['get_ai_recommendation(uint64,uint64)(uint64,string)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getAiRecommendation(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_ai_recommendation(uint64,uint64)(uint64,string)', v))
        return this
      },
      /**
       * Add a update_addresses(byte[],byte[],byte[])string method call against the YTAutoConverter contract
       */
      updateAddresses(params: CallParams<YtAutoConverterArgs['obj']['update_addresses(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['update_addresses(byte[],byte[],byte[])string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAddresses(params)))
        resultMappers.push((v) => client.decodeReturnValue('update_addresses(byte[],byte[],byte[])string', v))
        return this
      },
      /**
       * Add a clear state call to the YTAutoConverter contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as YtAutoConverterComposer
  }
}
export type YtAutoConverterComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the initialize(byte[],byte[],byte[])string ABI method.
   *
   * Initialize the auto converter
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  initialize(params?: CallParams<YtAutoConverterArgs['obj']['initialize(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['initialize(byte[],byte[],byte[])string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['initialize(byte[],byte[],byte[])string'] | undefined]>

  /**
   * Calls the configure_conversion(uint64,uint64,uint64)string ABI method.
   *
   * Configure automatic conversion for user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  configureConversion(params?: CallParams<YtAutoConverterArgs['obj']['configure_conversion(uint64,uint64,uint64)string'] | YtAutoConverterArgs['tuple']['configure_conversion(uint64,uint64,uint64)string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['configure_conversion(uint64,uint64,uint64)string'] | undefined]>

  /**
   * Calls the deposit_yt_tokens(uint64)string ABI method.
   *
   * Deposit YT tokens for conversion (for testing)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  depositYtTokens(params?: CallParams<YtAutoConverterArgs['obj']['deposit_yt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['deposit_yt_tokens(uint64)string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['deposit_yt_tokens(uint64)string'] | undefined]>

  /**
   * Calls the execute_conversion(byte[],uint64,uint64)string ABI method.
   *
   * Execute YT to PT conversion
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  executeConversion(params?: CallParams<YtAutoConverterArgs['obj']['execute_conversion(byte[],uint64,uint64)string'] | YtAutoConverterArgs['tuple']['execute_conversion(byte[],uint64,uint64)string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['execute_conversion(byte[],uint64,uint64)string'] | undefined]>

  /**
   * Calls the can_execute_conversion(byte[])uint64 ABI method.
   *
   * Check if conversion can be executed for user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  canExecuteConversion(params?: CallParams<YtAutoConverterArgs['obj']['can_execute_conversion(byte[])uint64'] | YtAutoConverterArgs['tuple']['can_execute_conversion(byte[])uint64']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['can_execute_conversion(byte[])uint64'] | undefined]>

  /**
   * Calls the get_user_config()(uint64,uint64,uint64,uint64) ABI method.
   *
   * Get user's conversion configuration
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getUserConfig(params?: CallParams<YtAutoConverterArgs['obj']['get_user_config()(uint64,uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_config()(uint64,uint64,uint64,uint64)']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['get_user_config()(uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the get_user_balances()(uint64,uint64) ABI method.
   *
   * Get user's YT and PT balances
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getUserBalances(params?: CallParams<YtAutoConverterArgs['obj']['get_user_balances()(uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_user_balances()(uint64,uint64)']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['get_user_balances()(uint64,uint64)'] | undefined]>

  /**
   * Calls the get_conversion_info()(uint64,uint64,uint64) ABI method.
   *
   * Get conversion information
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getConversionInfo(params?: CallParams<YtAutoConverterArgs['obj']['get_conversion_info()(uint64,uint64,uint64)'] | YtAutoConverterArgs['tuple']['get_conversion_info()(uint64,uint64,uint64)']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['get_conversion_info()(uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the calculate_conversion_output(uint64)(uint64,uint64) ABI method.
   *
   * Calculate expected PT output for YT input
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateConversionOutput(params?: CallParams<YtAutoConverterArgs['obj']['calculate_conversion_output(uint64)(uint64,uint64)'] | YtAutoConverterArgs['tuple']['calculate_conversion_output(uint64)(uint64,uint64)']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['calculate_conversion_output(uint64)(uint64,uint64)'] | undefined]>

  /**
   * Calls the add_maturity(uint64)string ABI method.
   *
   * Add a maturity for conversion
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addMaturity(params?: CallParams<YtAutoConverterArgs['obj']['add_maturity(uint64)string'] | YtAutoConverterArgs['tuple']['add_maturity(uint64)string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['add_maturity(uint64)string'] | undefined]>

  /**
   * Calls the remove_maturity()string ABI method.
   *
   * Remove user's maturity
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  removeMaturity(params?: CallParams<YtAutoConverterArgs['obj']['remove_maturity()string'] | YtAutoConverterArgs['tuple']['remove_maturity()string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['remove_maturity()string'] | undefined]>

  /**
   * Calls the set_conversion_fee(uint64)string ABI method.
   *
   * Set conversion fee (admin only)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setConversionFee(params?: CallParams<YtAutoConverterArgs['obj']['set_conversion_fee(uint64)string'] | YtAutoConverterArgs['tuple']['set_conversion_fee(uint64)string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['set_conversion_fee(uint64)string'] | undefined]>

  /**
   * Calls the pause_converter()string ABI method.
   *
   * Pause the converter (admin only)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  pauseConverter(params?: CallParams<YtAutoConverterArgs['obj']['pause_converter()string'] | YtAutoConverterArgs['tuple']['pause_converter()string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['pause_converter()string'] | undefined]>

  /**
   * Calls the unpause_converter()string ABI method.
   *
   * Unpause the converter (admin only)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  unpauseConverter(params?: CallParams<YtAutoConverterArgs['obj']['unpause_converter()string'] | YtAutoConverterArgs['tuple']['unpause_converter()string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['unpause_converter()string'] | undefined]>

  /**
   * Calls the emergency_disable_conversion()string ABI method.
   *
   * Emergency disable conversion for user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  emergencyDisableConversion(params?: CallParams<YtAutoConverterArgs['obj']['emergency_disable_conversion()string'] | YtAutoConverterArgs['tuple']['emergency_disable_conversion()string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['emergency_disable_conversion()string'] | undefined]>

  /**
   * Calls the withdraw_pt_tokens(uint64)string ABI method.
   *
   * Withdraw PT tokens
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdrawPtTokens(params?: CallParams<YtAutoConverterArgs['obj']['withdraw_pt_tokens(uint64)string'] | YtAutoConverterArgs['tuple']['withdraw_pt_tokens(uint64)string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['withdraw_pt_tokens(uint64)string'] | undefined]>

  /**
   * Calls the get_ai_recommendation(uint64,uint64)(uint64,string) ABI method.
   *
   * Get AI recommendation for conversion (simplified)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getAiRecommendation(params?: CallParams<YtAutoConverterArgs['obj']['get_ai_recommendation(uint64,uint64)(uint64,string)'] | YtAutoConverterArgs['tuple']['get_ai_recommendation(uint64,uint64)(uint64,string)']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['get_ai_recommendation(uint64,uint64)(uint64,string)'] | undefined]>

  /**
   * Calls the update_addresses(byte[],byte[],byte[])string ABI method.
   *
   * Update contract addresses (admin only)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAddresses(params?: CallParams<YtAutoConverterArgs['obj']['update_addresses(byte[],byte[],byte[])string'] | YtAutoConverterArgs['tuple']['update_addresses(byte[],byte[],byte[])string']>): YtAutoConverterComposer<[...TReturns, YtAutoConverterReturns['update_addresses(byte[],byte[],byte[])string'] | undefined]>

  /**
   * Makes a clear_state call to an existing instance of the YTAutoConverter smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): YtAutoConverterComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): YtAutoConverterComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<YtAutoConverterComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<YtAutoConverterComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<YtAutoConverterComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<YtAutoConverterComposerResults<TReturns>>
}
export type YtAutoConverterComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

